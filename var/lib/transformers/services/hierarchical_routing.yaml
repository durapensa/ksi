---
# Dynamic Hierarchical Event Routing
# 
# This file defines dynamic routing patterns that work with agent-controlled
# hierarchical relationships. Instead of static is_ancestor() functions,
# relationships are discovered through routing rules and state queries.
#
# DEPRECATED PATTERNS REMOVED:
# - Static orchestration-based routing (replaced by dynamic routing)
# - Explicit monitor routing (universal * â†’ monitor:broadcast_event handles this)
# - Hardcoded hierarchy functions (replaced by routing rule queries)
#
transformers:
  # Agent Error Bubbling Pattern
  # Agents control their error_propagation_level in state:
  # 0 = no propagation (default)
  # 1 = direct parents only
  # 2 = two levels up
  # -1 = all ancestors
  #
  # The system:error handler implements this via find_parent_agents()
  # which queries routing rules to discover parent relationships dynamically.
  
  # Peer-to-Peer Communication (Dynamic)
  - name: "peer_communication_dynamic"
    source: "agent:peer_message"
    target: "completion:async"
    condition: "routing_rule_exists(source_agent_id, target_agent_id, 'peer')"
    mapping:
      agent_id: "{{target_agent_id}}"
      prompt: "Peer message from {{source_agent_id}}: {{message_type}}"
      peer_message:
        from_peer: "{{source_agent_id}}"
        message_type: "{{message_type}}"
        data: "{{message_data}}"
        timestamp: "{{timestamp_utc()}}"
        conversation_id: "{{conversation_id|generate_uuid()}}"
      context:
        notification_type: "peer_communication"
        response_expected: "{{expect_response|false}}"
    description: "Route peer messages based on dynamic routing rules"

  # Capability-Based Routing (Dynamic)
  - name: "capability_based_routing"
    source: "agent:capability_event"
    target: "completion:async"
    condition: "agent_has_capability(target_agent_id, required_capability)"
    mapping:
      agent_id: "{{target_agent_id}}"
      prompt: "Capability-specific event: {{event_name}}"
      capability_event:
        required_capability: "{{required_capability}}"
        event: "{{event_name}}"
        data: "{{event_data}}"
        source_agent: "{{source_agent_id}}"
        capability_level: "{{get_agent_capability_level(target_agent_id, required_capability)}}"
      context:
        notification_type: "capability_filtered"
        response_required: "{{requires_capability_response}}"
    foreach: "agents_with_capability({{required_capability}})"
    description: "Route events only to agents with specific capabilities"

  # Broadcast to Agent Group (Dynamic)
  - name: "group_broadcast_dynamic"
    source: "group:broadcast"
    target: "completion:async"
    condition: "agent_in_group(target_agent_id, group_id)"
    mapping:
      agent_id: "{{target_agent_id}}"
      prompt: "Group broadcast in {{group_id}}: {{message}}"
      broadcast_data:
        group_id: "{{group_id}}"
        message: "{{message}}"
        broadcast_time: "{{timestamp_utc()}}"
        sender: "{{sender_agent_id|system}}"
        priority: "{{priority|normal}}"
      context:
        notification_type: "group_broadcast"
        no_response_required: true
    foreach: "agents_in_group({{group_id}})"
    description: "Broadcast messages to all agents in a group"

  # Task Distribution Based on Load
  - name: "load_balanced_task_distribution"
    source: "task:distribute"
    target: "completion:async"
    condition: "agent_load(target_agent_id) < max_load"
    mapping:
      agent_id: "{{select_least_loaded_agent(task_type)}}"
      prompt: "New task assigned: {{task_type}}"
      task_data:
        task_id: "{{task_id}}"
        task_type: "{{task_type}}"
        payload: "{{task_payload}}"
        deadline: "{{deadline|null}}"
        priority: "{{priority|normal}}"
      context:
        notification_type: "task_assignment"
        acknowledgment_required: true
    description: "Distribute tasks to least loaded capable agents"

  # Result Aggregation Pattern
  - name: "result_aggregation"
    source: "agent:result"
    target: "aggregation:collect"
    condition: "is_aggregation_target(aggregation_id)"
    mapping:
      aggregation_id: "{{aggregation_id}}"
      contributor_id: "{{source_agent_id}}"
      result_data: "{{result}}"
      timestamp: "{{timestamp_utc()}}"
      sequence: "{{result_sequence|null}}"
    description: "Collect results from multiple agents for aggregation"

  # Dynamic Coordination Pattern
  - name: "coordination_request"
    source: "agent:coordination_request"
    target: "routing:add_rule"
    condition: "agent_has_capability(source_agent_id, 'routing_control')"
    mapping:
      rule_name: "coordination_{{source_agent_id}}_{{target_agent_id}}_{{timestamp_utc()}}"
      source_pattern: "{{source_pattern}}"
      target_event: "{{target_event}}"
      relationship: "{{relationship_type|coordination}}"
      persistence_class: "{{persistence|ephemeral}}"
      created_by: "{{source_agent_id}}"
    description: "Allow agents with routing_control to establish coordination patterns"