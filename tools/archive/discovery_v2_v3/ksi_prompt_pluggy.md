# KSI System Interface

You have access to KSI (Knowledge System Interface), a daemon that manages AI processes with conversation continuity and multi-agent orchestration. This prompt explains how to use KSI effectively.

## Quick Start

To use KSI, send JSON events to the daemon. Each event follows this format:
```json
{"event": "namespace:action", "data": {parameters}}
```

## Core Capabilities

### 1. Completions - Run AI models with session continuity

**Create a completion request:**
```json
{"event": "completion:async", "data": {
  "prompt": "Your prompt here",
  "model": "claude-cli/sonnet",    // or "claude-cli/opus"
  "session_id": "optional-session-id-from-previous-response"
}}
```

The daemon returns a `request_id` immediately. The actual completion runs asynchronously and saves to `var/logs/responses/sessions/{new_session_id}.jsonl`.

**Key points about sessions:**
- Omit `session_id` for new conversations (clean context)
- Each response returns a NEW session_id for the next request
- Use the returned session_id to continue conversations
- Session IDs are generated by claude-cli and cannot be changed

**Check completion status:**
```json
{"event": "completion:status", "data": {}}
{"event": "completion:session_status", "data": {"session_id": "your-session-id"}}
```

**Cancel a running completion:**
```json
{"event": "completion:cancel", "data": {"request_id": "request-id-to-cancel"}}
```

### 2. Conversations - Find and analyze past interactions

**List active conversations:**
```json
{"event": "conversation:active", "data": {}}
```

**Search conversations by content:**
```json
{"event": "conversation:search", "data": {
  "query": "search terms",
  "limit": 20
}}
```

**Export conversation to markdown/JSON:**
```json
{"event": "conversation:export", "data": {
  "session_id": "session-to-export",
  "format": "markdown"  // or "json"
}}
```

### 3. State Management - Persistent key-value storage

**Store data:**
```json
{"event": "state:set", "data": {
  "key": "my_key",
  "value": {"any": "json", "data": "here"}
}}
```

**Retrieve data:**
```json
{"event": "state:get", "data": {"key": "my_key"}}
```

**List all keys:**
```json
{"event": "state:list", "data": {}}
```

**Shared state across agents:**
Use the `shared:` prefix for keys that should be accessible to all agents:
```json
{"event": "state:set", "data": {
  "key": "shared:project_context",
  "value": {"description": "Building a web app"}
}}
```

### 4. Agent Management - Spawn and coordinate AI agents

**Spawn an agent with a specific profile:**
```json
{"event": "agent:spawn", "data": {
  "agent_id": "researcher_001",
  "composition": "profiles/researcher",
  "session_id": "optional-session-to-join"
}}
```

**Send message to an agent:**
```json
{"event": "agent:send_message", "data": {
  "agent_id": "researcher_001",
  "message": "Please analyze the codebase structure"
}}
```

**List active agents:**
```json
{"event": "agent:list", "data": {}}
```

**Terminate an agent:**
```json
{"event": "agent:terminate", "data": {
  "agent_id": "researcher_001"
}}
```

### 5. Monitoring - Track system activity

**Get recent events:**
```json
{"event": "monitor:get_events", "data": {
  "event_patterns": ["completion:*", "agent:*"],
  "limit": 50,
  "since": "1h ago"
}}
```

**Get system statistics:**
```json
{"event": "monitor:get_stats", "data": {}}
```

**Follow event correlation chains:**
```json
{"event": "monitor:get_correlation_chain", "data": {
  "correlation_id": "correlation-id-to-trace"
}}
```

## Advanced Features

### Composition System

The composition system allows dynamic agent configuration:

**List available compositions:**
```json
{"event": "composition:list", "data": {"type": "profiles"}}
```

**Get composition details:**
```json
{"event": "composition:get", "data": {
  "type": "profiles",
  "name": "researcher"
}}
```

**Create runtime composition:**
```json
{"event": "composition:create", "data": {
  "type": "profiles",
  "name": "custom_analyst",
  "definition": {
    "extends": "base_agent",
    "capabilities": ["code_analysis", "documentation"]
  }
}}
```

### Permission Profiles

Control agent capabilities with permission profiles:

**Available profiles:**
- `restricted`: Basic read-only access
- `standard`: Read/write with limited tools
- `trusted`: Full tool access except system commands
- `researcher`: Specialized for research tasks

**Set agent permissions:**
```json
{"event": "permission:set_agent", "data": {
  "agent_id": "my_agent",
  "profile": "standard"
}}
```

### Message Bus

Enable inter-agent communication:

**Subscribe to messages:**
```json
{"event": "message:subscribe", "data": {
  "channel": "research_findings",
  "subscriber_id": "coordinator_agent"
}}
```

**Publish messages:**
```json
{"event": "message:publish", "data": {
  "channel": "research_findings", 
  "message": {"finding": "Important pattern detected"}
}}
```

## Best Practices

1. **Session Management**: Always use session IDs from previous responses for continuity
2. **Agent Coordination**: Use shared state and message bus for agent collaboration
3. **Error Handling**: Check completion status before assuming success
4. **Resource Cleanup**: Terminate agents when done to free resources
5. **Monitoring**: Use event patterns to track specific subsystems

## System Discovery

To explore all available capabilities:

```json
{"event": "system:discover", "data": {}}
```

For detailed help on any event:

```json
{"event": "system:help", "data": {"event": "namespace:action"}}
```

## Common Workflows

### Multi-turn Conversation
```bash
# First message - no session_id
{"event": "completion:async", "data": {"prompt": "Hello", "model": "claude-cli/sonnet"}}
# Returns: request_id and creates file with NEW session_id

# Continue conversation using previous session_id
{"event": "completion:async", "data": {
  "prompt": "What did we just discuss?",
  "model": "claude-cli/sonnet",
  "session_id": "session-id-from-previous-response"
}}
```

### Research with Multiple Agents
```bash
# 1. Spawn researcher agent
{"event": "agent:spawn", "data": {"agent_id": "researcher", "composition": "profiles/researcher"}}

# 2. Spawn coordinator agent
{"event": "agent:spawn", "data": {"agent_id": "coordinator", "composition": "profiles/coordinator"}}

# 3. Set up message channel
{"event": "message:subscribe", "data": {"channel": "findings", "subscriber_id": "coordinator"}}

# 4. Send research task
{"event": "agent:send_message", "data": {
  "agent_id": "researcher",
  "message": "Analyze the architecture of this codebase"
}}
```

Remember: KSI is event-driven and asynchronous. Most operations return immediately with a request_id or status, and actual work happens in the background.