#!/usr/bin/env python3\n"""\nInjection Router Plugin\n\nRoutes async completion results through system-reminder injection to enable\nautonomous agent coordination through completion chains.\n"""\n\nimport asyncio\nimport json\nimport time\nfrom queue import Queue\nfrom typing import Dict, Any, Optional\nimport pluggy\n\nfrom ksi_common.logging import get_logger\nfrom ksi_daemon.plugin_utils import plugin_metadata\nfrom ksi_daemon.config import config\nfrom ksi_common import TimestampManager\n\n# Plugin metadata\nplugin_metadata("injection_router", version="1.0.0",\n                description="Routes async completion results through injection")\n\n# Hook implementation marker\nhookimpl = pluggy.HookimplMarker("ksi")\n\n# Module state\nlogger = get_logger("injection_router")\ninjection_queue = Queue()\ninjection_metadata_store: Dict[str, Dict[str, Any]] = {}\n\n# Event emitter reference (set during startup)\nevent_emitter = None\n\n# Import prompt composer when available\ntry:\n    from prompts.composer import PromptComposer\n    composer = PromptComposer()\nexcept ImportError:\n    logger.warning("PromptComposer not available, using fallback injection formatting")\n    composer = None\n\n\nclass InjectionCircuitBreaker:\n    """Basic circuit breaker for injection safety."""\n    \n    def __init__(self):\n        self.request_depth_tracker: Dict[str, int] = {}\n        self.blocked_requests = set()\n    \n    def check_injection_allowed(self, metadata: Dict[str, Any]) -> bool:\n        """Check if injection should be allowed based on circuit breaker rules."""\n        request_id = metadata.get('id')\n        \n        # Check if already blocked\n        if request_id in self.blocked_requests:\n            return False\n        \n        # Check depth\n        circuit_config = metadata.get('circuit_breaker_config', {})\n        parent_id = circuit_config.get('parent_request_id')\n        max_depth = circuit_config.get('max_depth', 5)\n        \n        if parent_id:\n            parent_depth = self.request_depth_tracker.get(parent_id, 0)\n            current_depth = parent_depth + 1\n            \n            if current_depth >= max_depth:\n                logger.warning(f"Injection blocked: depth {current_depth} exceeds max {max_depth}")\n                self.blocked_requests.add(request_id)\n                return False\n            \n            self.request_depth_tracker[request_id] = current_depth\n        else:\n            self.request_depth_tracker[request_id] = 0\n        \n        return True\n    \n    def get_status(self, parent_request_id: Optional[str]) -> Dict[str, Any]:\n        """Get current circuit breaker status for a request chain."""\n        if not parent_request_id:\n            return {\n                'depth': 0,\n                'max_depth': 5,\n                'tokens_used': 0,\n                'token_budget': 50000,\n                'time_elapsed': 0,\n                'time_window': 3600\n            }\n        \n        depth = self.request_depth_tracker.get(parent_request_id, 0) + 1\n        \n        return {\n            'depth': depth,\n            'max_depth': 5,\n            'tokens_used': 0,  # Token tracking not yet implemented\n            'token_budget': 50000,\n            'time_elapsed': 0,  # Time tracking not yet implemented\n            'time_window': 3600\n        }\n\n\n# Global circuit breaker instance\ncircuit_breaker = InjectionCircuitBreaker()\n\n\n@hookimpl\ndef ksi_startup(config):\n    """Initialize injection router on startup."""\n    logger.info("Injection router started")\n    return {"status": "injection_router_ready"}\n\n\n@hookimpl\ndef ksi_plugin_context(context):\n    """Store event emitter reference."""\n    global event_emitter\n    event_emitter = context.get("emit_event")\n\n\n@hookimpl\ndef ksi_ready():\n    """Return async task to process injection queue."""\n    logger.info("Injection router ksi_ready called - returning queue processor task")\n    \n    async def process_injection_queue():\n        """Process queued injections."""\n        logger.info("Starting injection queue processor")\n        \n        while True:\n            try:\n                # Get next injection request (blocking)\n                injection_request = await asyncio.get_event_loop().run_in_executor(\n                    None, injection_queue.get\n                )\n                \n                if injection_request is None:  # Shutdown signal\n                    logger.info("Injection queue processor shutting down")\n                    break\n                \n                logger.debug(f"Processing injection for session {injection_request.get('session_id')}")\n                \n                # Execute the injection\n                if event_emitter:\n                    logger.debug(f"Executing injection with data: {injection_request}")\n                    result = await execute_injection(injection_request, {})\n                    logger.debug(f"Injection result: {result}")\n                else:\n                    logger.error("Event emitter not available for injection processing")\n                    \n            except Exception as e:\n                logger.error(f"Error processing injection: {e}", exc_info=True)\n                await asyncio.sleep(1)  # Brief pause on error\n        \n        logger.info("Injection queue processor stopped")\n    \n    return {\n        "service": "injection_router",\n        "tasks": [\n            {\n                "name": "injection_queue_processor",\n                "coroutine": process_injection_queue()\n            }\n        ]\n    }\n\n\n@hookimpl\ndef ksi_handle_event(event_name: str, data: Dict[str, Any], context: Dict[str, Any]):\n    """Handle injection-related events."""\n    \n    if event_name == "completion:result":\n        # Return async coroutine for daemon to await\n        return handle_completion_result(data, context)\n    \n    elif event_name == "injection:execute":\n        # Return async coroutine for daemon to await\n        return execute_injection(data, context)\n    \n    elif event_name == "injection:status":\n        return {\n            "queued_count": injection_queue.qsize(),\n            "metadata_count": len(injection_metadata_store),\n            "blocked_count": len(circuit_breaker.blocked_requests)\n        }\n    \n    return None\n\n\nasync def handle_completion_result(data: Dict[str, Any], context: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n    """Process completion result and queue injection if configured."""\n    \n    request_id = data.get('request_id')\n    completion_text = data.get('result') or data.get('completion_text', '')\n    \n    # Check for error responses\n    if data.get('status') == 'error':\n        logger.warning(f"Completion error for {request_id}, skipping injection")\n        return None\n    \n    # Retrieve injection metadata\n    injection_metadata = get_injection_metadata(request_id)\n    \n    if not injection_metadata:\n        logger.debug(f"No injection metadata for {request_id}")\n        return None\n    \n    injection_config = injection_metadata.get('injection_config', {})\n    \n    if not injection_config.get('enabled'):\n        logger.debug(f"Injection not enabled for {request_id}")\n        return None\n    \n    # Check if this is already an injection (prevent recursion)\n    if injection_metadata.get('is_injection'):\n        logger.debug(f"Skipping injection for injected completion {request_id}")\n        return None\n    \n    # Check circuit breakers\n    if not circuit_breaker.check_injection_allowed(injection_metadata):\n        logger.warning(f"Injection blocked by circuit breaker for {request_id}")\n        \n        # Emit blocked event\n        if event_emitter:\n            asyncio.create_task(event_emitter("injection:blocked", {\n                "request_id": request_id,\n                "reason": "circuit_breaker"\n            }))\n        \n        return {"injection:blocked": {"request_id": request_id}}\n    \n    # Compose injection content\n    try:\n        injection_content = compose_injection_content(\n            completion_text, data, injection_metadata\n        )\n    except Exception as e:\n        logger.error(f"Failed to compose injection for {request_id}: {e}")\n        return {"error": f"Injection composition failed: {e}"}\n    \n    # Determine injection mode\n    injection_mode = injection_config.get('mode', 'next')  # Default to "next" mode\n    position = injection_config.get('position', 'prepend')  # Default to prepend\n    \n    # Handle based on mode\n    if injection_mode == 'direct':\n        # Direct mode: Queue for immediate completion (original behavior)\n        target_sessions = injection_config.get('target_sessions', ['originating'])\n        queued_count = 0\n        \n        for session_id in target_sessions:\n            injection_request = {\n                'session_id': session_id,\n                'content': injection_content,\n                'parent_request_id': request_id,\n                'is_injection': True,  # Prevent recursive injection\n                'timestamp': TimestampManager.timestamp_utc()\n            }\n            \n            injection_queue.put(injection_request)\n            queued_count += 1\n            \n            # Emit queued event\n            if event_emitter:\n                asyncio.create_task(event_emitter("injection:queued", {\n                    "request_id": request_id,\n                    "session_id": session_id,\n                    "mode": "direct"\n                }))\n        \n        logger.info(f"Queued {queued_count} direct injections for request {request_id}")\n        \n        return {\n            "injection:queued": {\n                "request_id": request_id,\n                "target_count": queued_count,\n                "mode": "direct"\n            }\n        }\n    \n    else:  # next mode\n        # Next mode: Store in async state for next request\n        target_sessions = injection_config.get('target_sessions', ['originating'])\n        stored_count = 0\n        \n        for session_id in target_sessions:\n            # Store injection in async state\n            injection_data = {\n                'content': injection_content,\n                'position': position,\n                'parent_request_id': request_id,\n                'timestamp': TimestampManager.timestamp_utc(),\n                'trigger_type': injection_config.get('trigger_type', 'general')\n            }\n            \n            # Use async_state API\n            if event_emitter:\n                result = await event_emitter("async_state:push", {\n                    "namespace": "injection",\n                    "key": session_id,\n                    "data": injection_data,\n                    "ttl_seconds": 3600  # 1 hour TTL\n                })\n                \n                if result and not result.get("error"):\n                    stored_count += 1\n                    \n                    # Emit stored event\n                    await event_emitter("injection:stored", {\n                        "request_id": request_id,\n                        "session_id": session_id,\n                        "mode": "next",\n                        "position": position\n                    })\n                else:\n                    logger.error(f"Failed to store injection for session {session_id}: {result}")\n        \n        logger.info(f"Stored {stored_count} next-mode injections for request {request_id}")\n        \n        return {\n            "injection:stored": {\n                "request_id": request_id,\n                "target_count": stored_count,\n                "mode": "next"\n            }\n        }\n\n\nasync def execute_injection(data: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:\n    """Execute a queued injection by creating a new completion request."""\n    \n    session_id = data.get('session_id')\n    content = data.get('content')\n    request_id = data.get('request_id')\n    target_sessions = data.get('target_sessions', [session_id] if session_id else [])\n    \n    if not content:\n        logger.error("No content provided for injection")\n        return {"status": "error", "error": "No content provided"}\n    \n    if not event_emitter:\n        logger.error("Event emitter not available for injection")\n        return {"status": "error", "error": "Event emitter not available"}\n    \n    logger.info(f"Executing injection for session {session_id}")\n    \n    # Create completion requests for each target session\n    results = []\n    for target_session in target_sessions:\n        try:\n            # Construct the completion request\n            completion_data = {\n                "prompt": content,\n                "session_id": target_session,\n                "model": data.get('model', 'claude-cli/sonnet'),  # Default model\n                "client_id": "injection_router",\n                "request_id": f"inj_{request_id}_{target_session}" if request_id else f"inj_{int(time.time() * 1000)}_{target_session}",\n                "priority": data.get('priority', 'normal'),\n                "injection_metadata": {\n                    "source_request": request_id,\n                    "injection_type": data.get('injection_type', 'system_reminder'),\n                    "timestamp": time.time()\n                }\n            }\n            \n            # Emit the completion request\n            result = await event_emitter("completion:async", completion_data)\n            results.append({\n                "target_session": target_session,\n                "status": "queued",\n                "request_id": completion_data["request_id"],\n                "result": result\n            })\n            \n            logger.info(f"Injected completion request {completion_data['request_id']} into session {target_session}")\n            \n        except Exception as e:\n            logger.error(f"Failed to inject into session {target_session}: {e}")\n            results.append({\n                "target_session": target_session,\n                "status": "error",\n                "error": str(e)\n            })\n    \n    return {\n        "status": "injection_executed",\n        "target_count": len(target_sessions),\n        "results": results\n    }\n\n\ndef get_injection_metadata(request_id: str) -> Optional[Dict[str, Any]]:\n    """Retrieve injection metadata for a request."""\n    \n    # First check our local store\n    if request_id in injection_metadata_store:\n        return injection_metadata_store[request_id]\n    \n    # Check persistent storage or state service (future enhancement)\n    \n    return None\n\n\ndef store_injection_metadata(request_id: str, metadata: Dict[str, Any]):\n    """Store injection metadata for a request."""\n    injection_metadata_store[request_id] = metadata\n\n\ndef compose_injection_content(completion_text: str, result_data: Dict[str, Any], \n                             metadata: Dict[str, Any]) -> str:\n    """Compose injection content using prompt composition system."""\n    \n    injection_config = metadata.get('injection_config', {})\n    circuit_breaker_config = metadata.get('circuit_breaker_config', {})\n    \n    # Calculate circuit breaker status\n    cb_status = circuit_breaker.get_status(\n        circuit_breaker_config.get('parent_request_id')\n    )\n    \n    # If composer is available, use it\n    if composer:\n        try:\n            # Prepare composition context\n            composition_context = {\n                'completion_result': completion_text,\n                'completion_attributes': result_data.get('attributes', {}),\n                'trigger_type': injection_config.get('trigger_type', 'general'),\n                'follow_up_guidance': injection_config.get('follow_up_guidance'),\n                'circuit_breaker_status': cb_status,\n                'pending_completion_result': True\n            }\n            \n            # Use specified template or default\n            template_name = injection_config.get('composition_template', 'async_completion_result')\n            \n            # Compose using template system\n            injection_prompt = composer.compose(template_name, composition_context)\n            \n            # Wrap in system-reminder tags\n            return f"<system-reminder>\n{injection_prompt}\n</system-reminder>"\n            \n        except Exception as e:\n            logger.error(f"Composer failed: {e}, using fallback")\n    \n    # Fallback formatting\n    trigger_type = injection_config.get('trigger_type', 'general')\n    follow_up_guidance = injection_config.get('follow_up_guidance', \n                                             'Consider if this requires any follow-up actions.')\n    \n    # Generate trigger boilerplate based on type\n    trigger_boilerplate = get_trigger_boilerplate(trigger_type)\n    \n    # Format circuit breaker status\n    cb_status_text = ""\n    if cb_status and cb_status['depth'] > 0:\n        cb_status_text = f"""\n## Circuit Breaker Status\n- Ideation Depth: {cb_status['depth']}/{cb_status['max_depth']}\n- Token Budget: {cb_status['tokens_used']}/{cb_status['token_budget']}\n- Time Window: {cb_status['time_elapsed']}/{cb_status['time_window']}s\n"""\n    \n    return f"""<system-reminder>\n## Async Completion Result\n\nAn asynchronous completion has returned with the following result:\n\n{completion_text}\n\n{trigger_boilerplate}\n\n{follow_up_guidance}\n{cb_status_text}\n</system-reminder>"""\n\n\ndef get_trigger_boilerplate(trigger_type: str) -> str:\n    """Get boilerplate text for different trigger types."""\n    \n    triggers = {\n        'antThinking': """\n## Analytical Thinking Trigger\n\nThis notification requires careful analytical consideration. Please think step-by-step about:\n\n1. **Implications**: What are the broader implications of this result?\n2. **Dependencies**: Which other agents or systems might be affected?\n3. **Actions**: What follow-up actions, if any, should be taken?\n4. **Risks**: Are there any risks or concerns to address?\n\nConsider whether to:\n- Send messages to specific agents\n- Initiate further research\n- Update organizational state\n- Document findings in collective memory\n""",\n        \n        'coordination': """\n## Coordination Trigger\n\nThis result has coordination implications. Consider:\n\n1. **Agent Notification**: Which agents need this information?\n2. **Organizational Impact**: How does this affect current coordination patterns?\n3. **Capability Changes**: Are there new capabilities to leverage?\n4. **Synchronization**: What state needs to be synchronized?\n\nCoordination actions to consider:\n- Broadcast to relevant agent groups\n- Update coordination patterns\n- Reallocate capabilities\n- Form new agent coalitions\n""",\n        \n        'research': """\n## Research Continuation Trigger\n\nThese findings suggest additional research opportunities:\n\n1. **Follow-up Questions**: What new questions arise from these results?\n2. **Knowledge Gaps**: What gaps in understanding remain?\n3. **Research Paths**: Which research directions seem most promising?\n4. **Resource Allocation**: What resources would be needed?\n\nResearch actions available:\n- Queue additional research tasks\n- Consult collective memory\n- Engage specialist agents\n- Synthesize with existing knowledge\n""",\n        \n        'memory': """\n## Memory Integration Trigger\n\nThis information may be valuable for collective memory:\n\n1. **Significance**: Is this finding significant enough to preserve?\n2. **Generalization**: Can this be generalized for future use?\n3. **Indexing**: How should this be categorized for retrieval?\n4. **Relationships**: How does this relate to existing memories?\n\nMemory actions:\n- Store in experience library\n- Update pattern recognition\n- Link to related memories\n- Tag for future retrieval\n""",\n        \n        'general': """\n## General Consideration\n\nPlease consider whether this result warrants any follow-up actions or communications.\n"""\n    }\n    \n    return triggers.get(trigger_type, triggers['general'])\n\n\n# Public API for other plugins\ndef queue_completion_with_injection(request: Dict[str, Any]) -> str:\n    """Queue a completion request with injection metadata."""\n    \n    # Generate request ID if not provided\n    request_id = request.get('id') or f"req_{int(time.time() * 1000)}"\n    \n    # Extract injection config\n    injection_config = request.get('injection_config', {})\n    \n    # Store metadata\n    metadata = {\n        'id': request_id,\n        'injection_config': injection_config,\n        'circuit_breaker_config': request.get('circuit_breaker_config', {}),\n        'timestamp': TimestampManager.timestamp_utc()\n    }\n    \n    store_injection_metadata(request_id, metadata)\n    \n    return request_id\n\n\n@hookimpl\ndef ksi_shutdown():\n    """Clean up on shutdown."""\n    # Signal queue processor to stop\n    injection_queue.put(None)\n    \n    # Clear any remaining items\n    while not injection_queue.empty():\n        try:\n            injection_queue.get_nowait()\n        except:\n            break\n    \n    logger.info("Injection router stopped")\n    return {"status": "injection_router_stopped"}\n\n\n# Module marker\nksi_plugin = True