#!/usr/bin/env python3\n"""\nSimplified Unix Socket Transport Plugin\n\nHandles Unix domain socket communication without complex inheritance.\n"""\n\nimport asyncio\nimport json\nimport os\nfrom pathlib import Path\nimport logging\nfrom typing import Dict, Any, Optional, Callable\nimport pluggy\n\nfrom ksi_common.logging import get_logger\nfrom ksi_daemon.plugin_utils import plugin_metadata\nfrom ksi_daemon.config import config\n\n# Plugin metadata\nplugin_metadata("unix_socket_transport", version="2.0.0",\n                description="Simplified Unix domain socket transport")\n\n# Hook implementation marker\nhookimpl = pluggy.HookimplMarker("ksi")\n\n# Module state\nlogger = get_logger("unix_socket_transport")\nserver = None\nevent_emitter: Optional[Callable] = None\nclient_connections = {}\n\n# Plugin info\nPLUGIN_INFO = {\n    "name": "unix_socket_transport",\n    "version": "2.0.0",\n    "description": "Unix domain socket transport layer"\n}\n\n# NOT reloadable due to active connections\n_reloadable = False\n_reload_reason = "Active socket connections would be disrupted"\n\n\nclass UnixSocketTransport:\n    """Simple Unix socket transport implementation."""\n    \n    def __init__(self, socket_path: str):\n        self.socket_path = socket_path\n        self.server = None\n        self.running = False\n    \n    def set_event_emitter(self, emitter: Callable):\n        """Set the event emitter function."""\n        global event_emitter\n        event_emitter = emitter\n        logger.info("Event emitter configured")\n    \n    async def start(self):\n        """Start the Unix socket server."""\n        if self.running:\n            return\n        \n        # Ensure socket directory exists\n        socket_dir = os.path.dirname(self.socket_path)\n        os.makedirs(socket_dir, exist_ok=True)\n        \n        # Remove existing socket file\n        if os.path.exists(self.socket_path):\n            os.unlink(self.socket_path)\n        \n        # Start server\n        self.server = await asyncio.start_unix_server(\n            handle_client,\n            path=self.socket_path\n        )\n        \n        self.running = True\n        logger.info(f"Unix socket transport started on {self.socket_path}")\n    \n    async def stop(self):\n        """Stop the Unix socket server."""\n        if not self.running:\n            return\n        \n        self.running = False\n        \n        if self.server:\n            self.server.close()\n            await self.server.wait_closed()\n        \n        # Clean up socket file\n        if os.path.exists(self.socket_path):\n            os.unlink(self.socket_path)\n        \n        logger.info("Unix socket transport stopped")\n\n\nasync def handle_client(reader, writer):\n    """Handle a client connection."""\n    client_addr = writer.get_extra_info('peername', 'unknown')\n    client_id = id(writer)\n    client_connections[client_id] = writer\n    \n    logger.debug(f"Client connected: {client_addr}")\n    \n    try:\n        while True:\n            # Read line-delimited JSON messages\n            line = await reader.readline()\n            if not line:\n                break\n            \n            try:\n                message = json.loads(line.decode('utf-8').strip())\n            except json.JSONDecodeError as e:\n                logger.error(f"Invalid JSON: {e}")\n                await send_response(writer, {"error": f"Invalid JSON: {e}"})\n                continue\n            \n            # Handle the message\n            response = await handle_message(message)\n            \n            # Send response\n            logger.debug(f"Got response to send: {response}")\n            if response:\n                await send_response(writer, response)\n            else:\n                logger.debug("No response to send")\n    \n    except asyncio.CancelledError:\n        raise\n    except Exception as e:\n        logger.error(f"Error handling client: {e}", exc_info=True)\n    finally:\n        # Clean up\n        del client_connections[client_id]\n        writer.close()\n        await writer.wait_closed()\n        logger.debug(f"Client disconnected: {client_addr}")\n\n\nasync def handle_message(message: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n    """Handle an incoming message."""\n    if not event_emitter:\n        logger.error("No event emitter configured")\n        return {"error": "Transport not initialized"}\n    \n    # Extract event info\n    event_name = message.get("event")\n    data = message.get("data", {})\n    correlation_id = message.get("correlation_id")\n    \n    if not event_name:\n        return {"error": "Missing event name"}\n    \n    try:\n        # Emit the event and get response\n        response = await event_emitter(event_name, data, correlation_id)\n        \n        # Handle async responses\n        if asyncio.iscoroutine(response) or asyncio.isfuture(response):\n            response = await response\n        \n        # Include correlation_id if present\n        if response and correlation_id:\n            response["correlation_id"] = correlation_id\n        \n        return response\n    \n    except Exception as e:\n        logger.error(f"Error handling event {event_name}: {e}", exc_info=True)\n        return {\n            "error": str(e),\n            "correlation_id": correlation_id\n        }\n\n\nasync def send_response(writer, response: Dict[str, Any]):\n    """Send a response to the client."""\n    try:\n        # Send newline-delimited JSON response\n        response_str = json.dumps(response) + '\n'\n        logger.debug(f"Sending response: {response_str.strip()}")\n        writer.write(response_str.encode('utf-8'))\n        await writer.drain()\n        logger.debug("Response sent successfully")\n    except Exception as e:\n        logger.error(f"Error sending response: {e}")\n\n\n# Global transport instance\ntransport_instance = None\n\n# Hook implementations\n@hookimpl\ndef ksi_startup(config):\n    """Initialize transport on startup."""\n    global transport_instance\n    \n    # Create transport instance\n    socket_path = str(config.socket_path)\n    transport_instance = UnixSocketTransport(socket_path)\n    \n    logger.info("Unix socket transport plugin starting")\n    return {"plugin.unix_socket_transport": {"loaded": True}}\n\n@hookimpl\ndef ksi_ready():\n    """Return long-running server task to keep daemon alive."""\n    global transport_instance\n    \n    if transport_instance:\n        logger.info("Starting Unix socket server task")\n        \n        async def run_server():\n            """Run the Unix socket server - keeps daemon alive."""\n            await transport_instance.start()\n            \n            # Keep server running until cancelled\n            try:\n                await asyncio.Future()  # Wait forever until cancelled\n            except asyncio.CancelledError:\n                logger.info("Server task cancelled - shutting down")\n                await transport_instance.stop()\n                raise\n        \n        return {\n            "service": "unix_socket_transport",\n            "tasks": [\n                {\n                    "name": "socket_server", \n                    "coroutine": run_server()\n                }\n            ]\n        }\n    \n    return None\n\n\n@hookimpl\ndef ksi_plugin_context(context):\n    """Receive context including event emitter."""\n    global transport_instance, event_emitter\n    \n    event_emitter = context.get("emit_event")\n    if transport_instance and event_emitter:\n        transport_instance.set_event_emitter(event_emitter)\n        logger.info("Transport configured with event emitter")\n\n\n@hookimpl\ndef ksi_create_transport(transport_type: str, config: Dict[str, Any]):\n    """Create Unix socket transport if requested."""\n    if transport_type != "unix":\n        return None\n    \n    logger.info(f"Creating unix socket transport with config: {config}")\n    \n    # Import daemon config to get default paths\n    from ksi_daemon.config import config as daemon_config\n    \n    # Get socket path from config or use default\n    socket_dir = config.get("socket_dir", str(daemon_config.socket_path.parent))\n    socket_path = os.path.join(socket_dir, "daemon.sock")\n    \n    return UnixSocketTransport(socket_path)\n\n\n@hookimpl\ndef ksi_shutdown():\n    """Clean up on shutdown."""\n    global server\n    if server:\n        asyncio.create_task(server.stop())\n    \n    logger.info("Unix socket transport plugin stopped")\n    return {"status": "unix_socket_transport_stopped"}\n\n\n# Module-level marker for plugin discovery\nksi_plugin = True