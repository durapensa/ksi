#!/usr/bin/env python3\n"""\nState Service Plugin\n\nProvides persistent state management using SQLite backend.\nWraps the SessionAndSharedStateManager for plugin architecture.\n"""\n\nimport json\nfrom typing import Dict, Any, Optional\nimport logging\nimport pluggy\n\nfrom ksi_common.logging import get_logger\nfrom ksi_daemon.plugin_utils import plugin_metadata\nfrom ksi_common import TimestampManager\nfrom ksi_daemon.session_and_shared_state_manager import SessionAndSharedStateManager\nfrom ksi_daemon.plugins.state.async_state_manager import AsyncStateManager, async_state_manager\n\n# Plugin metadata\nplugin_metadata("state_service", version="3.0.0", \n                description="SQLite-backed persistent state management")\n\n# Hook implementation marker\nhookimpl = pluggy.HookimplMarker("ksi")\n\n# Module state\nlogger = get_logger("state_service")\nstate_manager: Optional[SessionAndSharedStateManager] = None\nasync_state_mgr: Optional[AsyncStateManager] = None\n\n# Plugin info\nPLUGIN_INFO = {\n    "name": "state_service",\n    "version": "3.0.0",\n    "description": "SQLite-backed persistent state management"\n}\n\n# Reload configuration\n_reloadable = True\n_reload_strategy = "stateful"\n_state_hooks = ["serialize_state", "deserialize_state"]\n\n\n# Hook implementations\n@hookimpl(tryfirst=True)  # Initialize early - other plugins depend on state service\ndef ksi_startup(config):\n    """Initialize state service on startup."""\n    global state_manager, async_state_mgr\n    \n    try:\n        state_manager = SessionAndSharedStateManager()\n        # BaseManager automatically calls _initialize() during construction\n        \n        # Initialize async state manager\n        from pathlib import Path\n        async_db_path = Path("var/db/async_state.db")\n        async_state_mgr = AsyncStateManager(async_db_path)\n        \n        # Set global reference\n        import ksi_daemon.plugins.state.async_state_manager as asm_module\n        asm_module.async_state_manager = async_state_mgr\n        \n        # Get current state counts\n        shared_count = len(state_manager.list_shared_state())\n        session_count = len(state_manager.sessions)\n        \n        logger.info(f"State service started - shared keys: {shared_count}, "\n                    f"sessions: {session_count}")\n        \n        return {\n            "status": "state_service_ready",\n            "shared_keys": shared_count,\n            "sessions": session_count,\n            "database": str(state_manager.db_path)\n        }\n    except Exception as e:\n        logger.error(f"Failed to initialize state service: {e}", exc_info=True)\n        return {\n            "status": "state_service_error", \n            "error": str(e)\n        }\n\n\n@hookimpl\ndef ksi_handle_event(event_name: str, data: Dict[str, Any], context: Dict[str, Any]):\n    """Handle state-related events."""\n    \n    if not state_manager:\n        return {"error": "State service not initialized"}\n    \n    # Get operation\n    if event_name == "state:get":\n        return handle_get(data)\n    \n    # Set operation\n    elif event_name == "state:set":\n        return handle_set(data)\n    \n    # Delete operation\n    elif event_name == "state:delete":\n        return handle_delete(data)\n    \n    # List keys\n    elif event_name == "state:list":\n        return handle_list(data)\n    \n    # Clear namespace\n    elif event_name == "state:clear":\n        return handle_clear(data)\n    \n    # Session operations\n    elif event_name == "state:session:update":\n        return handle_session_update(data)\n    \n    elif event_name == "state:session:get":\n        return handle_session_get(data)\n    \n    # Async state operations (queue-like)\n    elif event_name == "async_state:push":\n        # Return coroutine for daemon to await\n        return handle_async_push(data)\n    \n    elif event_name == "async_state:pop":\n        return handle_async_pop(data)\n    \n    elif event_name == "async_state:peek":\n        return handle_async_peek(data)\n    \n    elif event_name == "async_state:queue_length":\n        return handle_async_queue_length(data)\n    \n    # Async state operations (key-value)\n    elif event_name == "async_state:set":\n        return handle_async_set(data)\n    \n    elif event_name == "async_state:get":\n        return handle_async_get(data)\n    \n    elif event_name == "async_state:delete":\n        return handle_async_delete(data)\n    \n    # Async state maintenance\n    elif event_name == "async_state:stats":\n        return handle_async_stats(data)\n    \n    elif event_name == "async_state:cleanup":\n        return handle_async_cleanup(data)\n    \n    return None\n\n\ndef handle_get(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle state get operation."""\n    namespace = data.get("namespace", "global")\n    key = data.get("key", "")\n    \n    if not key:\n        return {"error": "Key is required"}\n    \n    # Handle shared: prefix for backward compatibility\n    if key.startswith("shared:"):\n        key = key[7:]  # Remove "shared:" prefix\n    \n    try:\n        # Prefix key with namespace if provided\n        full_key = f"{namespace}:{key}" if namespace != "global" else key\n        value = state_manager.get_shared_state(full_key)\n        return {\n            "value": value,\n            "found": value is not None,\n            "namespace": namespace,\n            "key": key\n        }\n    except Exception as e:\n        logger.error(f"Error getting state: {e}")\n        return {"error": str(e)}\n\n\ndef handle_set(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle state set operation."""\n    namespace = data.get("namespace", "global") \n    key = data.get("key", "")\n    value = data.get("value")\n    metadata = data.get("metadata", {})\n    \n    if not key:\n        return {"error": "Key is required"}\n    \n    # Handle shared: prefix for backward compatibility\n    if key.startswith("shared:"):\n        key = key[7:]  # Remove "shared:" prefix\n    \n    try:\n        # Prefix key with namespace if provided\n        full_key = f"{namespace}:{key}" if namespace != "global" else key\n        state_manager.set_shared_state(full_key, value, metadata=metadata)\n        return {\n            "status": "set",\n            "namespace": namespace,\n            "key": key\n        }\n    except Exception as e:\n        logger.error(f"Error setting state: {e}")\n        return {"error": str(e)}\n\n\ndef handle_delete(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle state delete operation."""\n    namespace = data.get("namespace", "global")\n    key = data.get("key", "")\n    \n    if not key:\n        return {"error": "Key is required"}\n    \n    # Handle shared: prefix for backward compatibility\n    if key.startswith("shared:"):\n        key = key[7:]  # Remove "shared:" prefix\n    \n    try:\n        # Prefix key with namespace if provided\n        full_key = f"{namespace}:{key}" if namespace != "global" else key\n        success = state_manager.remove_shared_state(full_key)\n        return {\n            "status": "deleted" if success else "not_found",\n            "namespace": namespace,\n            "key": key\n        }\n    except Exception as e:\n        logger.error(f"Error deleting state: {e}")\n        return {"error": str(e)}\n\n\ndef handle_list(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle state list operation."""\n    namespace = data.get("namespace")\n    pattern = data.get("pattern")\n    \n    try:\n        # Get all shared state\n        all_state = state_manager.list_shared_state()\n        \n        # Filter by namespace and pattern\n        keys = []\n        for item in all_state:\n            key = item['key']\n            \n            # Check namespace match\n            if namespace:\n                if namespace == "global" and ":" in key:\n                    continue  # Skip namespaced keys\n                elif namespace != "global" and not key.startswith(f"{namespace}:"):\n                    continue  # Skip keys from other namespaces\n            \n            # Check pattern match (simple substring for now)\n            if pattern and pattern not in key:\n                continue\n                \n            # Remove namespace prefix for display\n            display_key = key\n            if namespace and namespace != "global" and key.startswith(f"{namespace}:"):\n                display_key = key[len(namespace)+1:]\n            \n            keys.append(display_key)\n        \n        return {\n            "keys": keys,\n            "count": len(keys),\n            "namespace": namespace,\n            "pattern": pattern\n        }\n    except Exception as e:\n        logger.error(f"Error listing keys: {e}")\n        return {"error": str(e)}\n\n\ndef handle_clear(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle state clear operation."""\n    namespace = data.get("namespace")\n    \n    if not namespace:\n        return {"error": "Namespace is required for clear operation"}\n    \n    try:\n        # Get all shared state\n        all_state = state_manager.list_shared_state()\n        \n        # Find and delete keys in namespace\n        deleted_count = 0\n        for item in all_state:\n            key = item['key']\n            \n            # Check if key belongs to namespace\n            if namespace == "global" and ":" not in key:\n                state_manager.remove_shared_state(key)\n                deleted_count += 1\n            elif namespace != "global" and key.startswith(f"{namespace}:"):\n                state_manager.remove_shared_state(key)\n                deleted_count += 1\n        \n        return {\n            "status": "cleared",\n            "namespace": namespace,\n            "keys_deleted": deleted_count\n        }\n    except Exception as e:\n        logger.error(f"Error clearing namespace: {e}")\n        return {"error": str(e)}\n\n\ndef handle_session_update(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle session update."""\n    session_id = data.get("session_id")\n    output = data.get("output")\n    \n    if not session_id:\n        return {"error": "session_id required"}\n    \n    try:\n        state_manager.update_session(session_id, output)\n        return {\n            "status": "updated",\n            "session_id": session_id\n        }\n    except Exception as e:\n        logger.error(f"Error updating session: {e}")\n        return {"error": str(e)}\n\n\ndef handle_session_get(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle session get."""\n    session_id = data.get("session_id")\n    \n    if not session_id:\n        return {"error": "session_id required"}\n    \n    try:\n        output = state_manager.get_session_output(session_id)\n        return {\n            "session_id": session_id,\n            "output": output,\n            "found": output is not None\n        }\n    except Exception as e:\n        logger.error(f"Error getting session: {e}")\n        return {"error": str(e)}\n\n\n@hookimpl\ndef ksi_shutdown():\n    """Clean up on shutdown."""\n    if state_manager:\n        try:\n            # State manager automatically commits on operations\n            logger.info("State service stopped")\n        except Exception as e:\n            logger.error(f"Error during state service shutdown: {e}")\n    \n    return {\n        "status": "state_service_stopped"\n    }\n\n\n@hookimpl\ndef ksi_serialize_state():\n    """Serialize state for reload."""\n    if not state_manager:\n        return None\n    \n    logger.info("Serializing state service state")\n    \n    # Get current state\n    return {\n        "sessions": state_manager.sessions.copy(),\n        "db_path": str(state_manager.db_path),\n        "identities": getattr(state_manager, 'identities', {})\n    }\n\n\n@hookimpl\ndef ksi_deserialize_state(state):\n    """Restore state after reload."""\n    if not state_manager or not state:\n        return\n    \n    logger.info("Restoring state service state")\n    \n    # Restore sessions\n    if "sessions" in state:\n        state_manager.sessions = state["sessions"]\n        logger.info(f"Restored {len(state_manager.sessions)} sessions")\n    \n    # DB path should already match from init\n    # Identities if any\n    if "identities" in state:\n        setattr(state_manager, 'identities', state["identities"])\n\n\n@hookimpl\ndef ksi_validate_reload():\n    """Validate if state service can be reloaded."""\n    # State service can always be reloaded since SQLite handles persistence\n    return {"valid": True}\n\n\n# Async state handlers\n\nasync def handle_async_push(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Push item to async queue."""\n    if not async_state_mgr:\n        return {"error": "Async state manager not initialized"}\n    \n    namespace = data.get("namespace", "default")\n    key = data.get("key")\n    item_data = data.get("data")\n    ttl_seconds = data.get("ttl_seconds")\n    \n    if not key:\n        return {"error": "Key is required"}\n    if item_data is None:\n        return {"error": "Data is required"}\n    \n    try:\n        position = await async_state_mgr.push(namespace, key, item_data, ttl_seconds)\n        return {\n            "status": "pushed",\n            "namespace": namespace,\n            "key": key,\n            "position": position\n        }\n    except Exception as e:\n        logger.error(f"Error pushing to async state: {e}")\n        return {"error": str(e)}\n\n\nasync def handle_async_pop(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Pop item from async queue."""\n    if not async_state_mgr:\n        return {"error": "Async state manager not initialized"}\n    \n    namespace = data.get("namespace", "default")\n    key = data.get("key")\n    \n    if not key:\n        return {"error": "Key is required"}\n    \n    try:\n        item = await async_state_mgr.pop(namespace, key)\n        return {\n            "status": "popped",\n            "namespace": namespace,\n            "key": key,\n            "data": item,\n            "found": item is not None\n        }\n    except Exception as e:\n        logger.error(f"Error popping from async state: {e}")\n        return {"error": str(e)}\n\n\nasync def handle_async_peek(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Peek at first item in async queue."""\n    if not async_state_mgr:\n        return {"error": "Async state manager not initialized"}\n    \n    namespace = data.get("namespace", "default")\n    key = data.get("key")\n    \n    if not key:\n        return {"error": "Key is required"}\n    \n    try:\n        item = await async_state_mgr.peek(namespace, key)\n        return {\n            "status": "peeked",\n            "namespace": namespace,\n            "key": key,\n            "data": item,\n            "found": item is not None\n        }\n    except Exception as e:\n        logger.error(f"Error peeking async state: {e}")\n        return {"error": str(e)}\n\n\nasync def handle_async_queue_length(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Get length of async queue."""\n    if not async_state_mgr:\n        return {"error": "Async state manager not initialized"}\n    \n    namespace = data.get("namespace", "default")\n    key = data.get("key")\n    \n    if not key:\n        return {"error": "Key is required"}\n    \n    try:\n        length = await async_state_mgr.queue_length(namespace, key)\n        return {\n            "namespace": namespace,\n            "key": key,\n            "length": length\n        }\n    except Exception as e:\n        logger.error(f"Error getting queue length: {e}")\n        return {"error": str(e)}\n\n\nasync def handle_async_set(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Set single async state value."""\n    if not async_state_mgr:\n        return {"error": "Async state manager not initialized"}\n    \n    namespace = data.get("namespace", "default")\n    key = data.get("key")\n    value_data = data.get("data")\n    ttl_seconds = data.get("ttl_seconds")\n    \n    if not key:\n        return {"error": "Key is required"}\n    if value_data is None:\n        return {"error": "Data is required"}\n    \n    try:\n        await async_state_mgr.set(namespace, key, value_data, ttl_seconds)\n        return {\n            "status": "set",\n            "namespace": namespace,\n            "key": key\n        }\n    except Exception as e:\n        logger.error(f"Error setting async state: {e}")\n        return {"error": str(e)}\n\n\nasync def handle_async_get(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Get single async state value."""\n    if not async_state_mgr:\n        return {"error": "Async state manager not initialized"}\n    \n    namespace = data.get("namespace", "default")\n    key = data.get("key")\n    \n    if not key:\n        return {"error": "Key is required"}\n    \n    try:\n        value = await async_state_mgr.get(namespace, key)\n        return {\n            "namespace": namespace,\n            "key": key,\n            "data": value,\n            "found": value is not None\n        }\n    except Exception as e:\n        logger.error(f"Error getting async state: {e}")\n        return {"error": str(e)}\n\n\nasync def handle_async_delete(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Delete async state entries."""\n    if not async_state_mgr:\n        return {"error": "Async state manager not initialized"}\n    \n    namespace = data.get("namespace", "default")\n    key = data.get("key")\n    \n    if not key:\n        return {"error": "Key is required"}\n    \n    try:\n        deleted = await async_state_mgr.delete(namespace, key)\n        return {\n            "status": "deleted",\n            "namespace": namespace,\n            "key": key,\n            "deleted_count": deleted\n        }\n    except Exception as e:\n        logger.error(f"Error deleting async state: {e}")\n        return {"error": str(e)}\n\n\nasync def handle_async_stats(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Get async state statistics."""\n    if not async_state_mgr:\n        return {"error": "Async state manager not initialized"}\n    \n    try:\n        stats = await async_state_mgr.get_stats()\n        return stats\n    except Exception as e:\n        logger.error(f"Error getting async state stats: {e}")\n        return {"error": str(e)}\n\n\nasync def handle_async_cleanup(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Clean up expired async state entries."""\n    if not async_state_mgr:\n        return {"error": "Async state manager not initialized"}\n    \n    try:\n        deleted = await async_state_mgr.cleanup_expired()\n        return {\n            "status": "cleaned",\n            "deleted_count": deleted\n        }\n    except Exception as e:\n        logger.error(f"Error cleaning up async state: {e}")\n        return {"error": str(e)}\n\n\n# Module-level marker for plugin discovery\nksi_plugin = True