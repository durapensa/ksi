#!/usr/bin/env python3\n"""\nComposition Service Plugin\n\nProvides unified declarative composition system for profiles, prompts, and system configs.\nAll configurations in KSI are treated as YAML-based compositions.\n"""\n\nimport asyncio\nimport json\nimport yaml\nimport re\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List, Set\nfrom dataclasses import dataclass, field\nimport logging\nimport pluggy\n\nfrom ksi_common.logging import get_logger\nfrom ksi_daemon.plugin_utils import plugin_metadata\nfrom ksi_common import TimestampManager\nfrom ksi_daemon.config import config\n\n# Plugin metadata\nplugin_metadata("composition_service", version="1.0.0",\n                description="Unified declarative composition system")\n\n# Hook implementation marker\nhookimpl = pluggy.HookimplMarker("ksi")\n\n# Module state\nlogger = get_logger("composition_service")\nstate_manager = None  # Will be set during startup\n\n# Base path for compositions (still used for file operations)\nVAR_DIR = Path("var")  # Relative to project root\nCOMPOSITIONS_BASE = VAR_DIR / "lib/compositions"\nFRAGMENTS_BASE = VAR_DIR / "lib/fragments"\nSCHEMAS_BASE = VAR_DIR / "lib/schemas"\n\n\n@dataclass\nclass CompositionComponent:\n    """A single component in a composition."""\n    name: str\n    source: Optional[str] = None\n    composition: Optional[str] = None\n    inline: Optional[Dict[str, Any]] = None\n    template: Optional[str] = None\n    vars: Dict[str, Any] = field(default_factory=dict)\n    condition: Optional[str] = None\n    conditions: Optional[Dict[str, List[str]]] = None\n\n\n@dataclass\nclass Composition:\n    """A complete composition definition."""\n    name: str\n    type: str\n    version: str\n    description: str\n    author: Optional[str] = None\n    extends: Optional[str] = None\n    mixins: List[str] = field(default_factory=list)\n    components: List[CompositionComponent] = field(default_factory=list)\n    variables: Dict[str, Dict[str, Any]] = field(default_factory=dict)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    \n    @classmethod\n    def from_yaml(cls, data: Dict[str, Any]) -> 'Composition':\n        """Create composition from YAML data."""\n        components = []\n        for comp_data in data.get('components', []):\n            components.append(CompositionComponent(**comp_data))\n        \n        return cls(\n            name=data['name'],\n            type=data['type'],\n            version=data['version'],\n            description=data['description'],\n            author=data.get('author'),\n            extends=data.get('extends'),\n            mixins=data.get('mixins', []),\n            components=components,\n            variables=data.get('variables', {}),\n            metadata=data.get('metadata', {})\n        )\n\n\ndef load_fragment(path: str) -> str:\n    """Load a text fragment from disk (no caching)."""\n    fragment_path = FRAGMENTS_BASE / path\n    if not fragment_path.exists():\n        raise FileNotFoundError(f"Fragment not found: {path}")\n    \n    return fragment_path.read_text()\n\n\ndef substitute_variables(text: str, variables: Dict[str, Any]) -> str:\n    """Substitute {{variable}} placeholders in text."""\n    def replace_var(match):\n        var_name = match.group(1).strip()\n        if var_name in variables:\n            value = variables[var_name]\n            # Handle different value types\n            if isinstance(value, (dict, list)):\n                return json.dumps(value, indent=2)\n            return str(value)\n        return match.group(0)  # Keep original if not found\n    \n    return re.sub(r'\{\{([^}]+)\}\}', replace_var, text)\n\n\ndef evaluate_condition(condition: str, variables: Dict[str, Any]) -> bool:\n    """Evaluate a simple condition expression."""\n    # Substitute variables in condition\n    condition = substitute_variables(condition, variables)\n    \n    # Remove {{ }} if still present (means variable was undefined)\n    if '{{' in condition:\n        return False\n    \n    # Simple evaluation - just check for truthiness\n    # In a real implementation, could use ast.literal_eval or similar\n    condition = condition.strip()\n    if condition.lower() in ('true', '1', 'yes'):\n        return True\n    elif condition.lower() in ('false', '0', 'no', ''):\n        return False\n    else:\n        # If it's any other non-empty string, consider it true\n        return bool(condition)\n\n\ndef evaluate_conditions(conditions: Dict[str, List[str]], variables: Dict[str, Any]) -> bool:\n    """Evaluate complex condition expressions."""\n    if 'all_of' in conditions:\n        for cond in conditions['all_of']:\n            if not evaluate_condition(cond, variables):\n                return False\n    \n    if 'any_of' in conditions:\n        any_true = False\n        for cond in conditions['any_of']:\n            if evaluate_condition(cond, variables):\n                any_true = True\n                break\n        if not any_true:\n            return False\n    \n    if 'none_of' in conditions:\n        for cond in conditions['none_of']:\n            if evaluate_condition(cond, variables):\n                return False\n    \n    return True\n\n\nasync def load_composition(name: str, comp_type: Optional[str] = None) -> Composition:\n    """Load a composition by name using index."""\n    if not state_manager:\n        raise RuntimeError("Composition index not available")\n        \n    # Determine full name\n    full_name = f"local:{name}" if ':' not in name else name\n    \n    # Get file path from index\n    file_path = state_manager.get_composition_path(full_name)\n    if not file_path or not file_path.exists():\n        raise FileNotFoundError(f"Composition not found: {name}")\n    \n    # Load directly from file (no cache)\n    logger.debug(f"Loading composition from {file_path}")\n    data = yaml.safe_load(file_path.read_text())\n    \n    # Validate type if specified\n    if comp_type and data.get('type') != comp_type:\n        raise ValueError(f"Composition {name} is type {data.get('type')}, expected {comp_type}")\n    \n    return Composition.from_yaml(data)\n\n\nasync def resolve_composition(\n    composition: Composition,\n    variables: Dict[str, Any],\n    visited: Optional[Set[str]] = None\n) -> Dict[str, Any]:\n    """Resolve a composition into its final form."""\n    if visited is None:\n        visited = set()\n    \n    if composition.name in visited:\n        raise ValueError(f"Circular reference detected: {composition.name}")\n    \n    visited.add(composition.name)\n    result = {}\n    \n    # Handle inheritance\n    if composition.extends:\n        base = await load_composition(composition.extends, composition.type)\n        base_result = await resolve_composition(base, variables, visited.copy())\n        result.update(base_result)\n    \n    # Handle mixins\n    for mixin_name in composition.mixins:\n        mixin = await load_composition(mixin_name, composition.type)\n        mixin_result = await resolve_composition(mixin, variables, visited.copy())\n        # Merge mixin results\n        for key, value in mixin_result.items():\n            if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n                result[key].update(value)\n            else:\n                result[key] = value\n    \n    # Apply variable defaults\n    for var_name, var_def in composition.variables.items():\n        if var_name not in variables and 'default' in var_def:\n            variables[var_name] = var_def['default']\n    \n    # Process components\n    for component in composition.components:\n        # Check conditions\n        if component.condition and not evaluate_condition(component.condition, variables):\n            continue\n        \n        if component.conditions and not evaluate_conditions(component.conditions, variables):\n            continue\n        \n        # Merge component vars with global vars\n        comp_vars = {**variables, **component.vars}\n        \n        # Process component based on type\n        if component.source:\n            # Load fragment\n            content = load_fragment(component.source)\n            content = substitute_variables(content, comp_vars)\n            result[component.name] = content\n            \n        elif component.composition:\n            # Nested composition\n            nested = await load_composition(component.composition)\n            nested_result = await resolve_composition(nested, comp_vars, visited.copy())\n            result[component.name] = nested_result\n            \n        elif component.inline:\n            # Inline content\n            result[component.name] = component.inline\n            \n        elif component.template:\n            # Template string\n            content = substitute_variables(component.template, comp_vars)\n            result[component.name] = content\n    \n    # Add metadata\n    result['_metadata'] = {\n        'composition': composition.name,\n        'type': composition.type,\n        'version': composition.version,\n        'resolved_at': TimestampManager.format_for_logging()\n    }\n    \n    return result\n\n\nasync def compose_profile(name: str, variables: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n    """Compose an agent profile."""\n    if variables is None:\n        variables = {}\n    \n    composition = await load_composition(name, "profile")\n    result = await resolve_composition(composition, variables)\n    \n    # Extract and structure profile data\n    profile = {\n        'name': name,\n        'composition': composition.name,\n        **result.get('agent_config', {}),\n        '_metadata': result['_metadata']\n    }\n    \n    # Add composed prompt if present\n    if 'prompt' in result:\n        profile['composed_prompt'] = result['prompt']\n    \n    return profile\n\n\nasync def compose_prompt(name: str, variables: Optional[Dict[str, Any]] = None) -> str:\n    """Compose a prompt template."""\n    if variables is None:\n        variables = {}\n    \n    composition = await load_composition(name, "prompt")\n    result = await resolve_composition(composition, variables)\n    \n    # Concatenate all text components\n    prompt_parts = []\n    for key, value in result.items():\n        if key.startswith('_'):\n            continue\n        if isinstance(value, str):\n            prompt_parts.append(value)\n        elif isinstance(value, dict) and 'content' in value:\n            prompt_parts.append(value['content'])\n    \n    return '\n\n'.join(prompt_parts)\n\n\n# Event handlers\n@hookimpl\ndef ksi_handle_event(event_name: str, data: Dict[str, Any], context: Dict[str, Any]):\n    """Handle composition events."""\n    \n    if event_name == "composition:compose":\n        # Generic composition\n        return handle_compose(data)\n    \n    elif event_name == "composition:profile":\n        # Profile-specific composition\n        return handle_compose_profile(data)\n    \n    elif event_name == "composition:prompt":\n        # Prompt-specific composition\n        return handle_compose_prompt(data)\n    \n    elif event_name == "composition:validate":\n        # Validate composition\n        return handle_validate(data)\n    \n    elif event_name == "composition:discover":\n        # Discover available compositions\n        return handle_discover(data)\n    \n    elif event_name == "composition:list":\n        # List compositions by type\n        return handle_list(data)\n    \n    elif event_name == "composition:get":\n        # Get composition definition\n        return handle_get(data)\n    \n    elif event_name == "composition:reload":\n        # Reload compositions from disk\n        return handle_reload(data)\n    \n    elif event_name == "composition:load_tree":\n        # Universal tree loading based on declared strategy\n        return handle_load_tree(data)\n    \n    elif event_name == "composition:load_bulk":\n        # Universal bulk loading for agent efficiency\n        return handle_load_bulk(data)\n    \n    elif event_name == "composition:select":\n        # Dynamic composition selection\n        return handle_select_composition(data)\n    \n    elif event_name == "composition:create":\n        # Runtime composition creation\n        return handle_create_composition(data)\n    \n    return None\n\n\nasync def handle_compose(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle generic composition request."""\n    name = data.get('name')\n    comp_type = data.get('type')\n    variables = data.get('variables', {})\n    \n    if not name:\n        return {'error': 'Composition name required'}\n    \n    try:\n        composition = await load_composition(name, comp_type)\n        result = await resolve_composition(composition, variables)\n        return {\n            'status': 'success',\n            'result': result\n        }\n    except Exception as e:\n        logger.error(f"Composition failed: {e}")\n        return {'error': str(e)}\n\n\nasync def handle_compose_profile(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle profile composition request."""\n    name = data.get('name')\n    variables = data.get('variables', {})\n    \n    if not name:\n        return {'error': 'Profile name required'}\n    \n    try:\n        profile = await compose_profile(name, variables)\n        return {\n            'status': 'success',\n            'profile': profile\n        }\n    except Exception as e:\n        logger.error(f"Profile composition failed: {e}")\n        return {'error': str(e)}\n\n\nasync def handle_compose_prompt(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle prompt composition request."""\n    name = data.get('name')\n    variables = data.get('variables', {})\n    \n    if not name:\n        return {'error': 'Prompt name required'}\n    \n    try:\n        prompt = await compose_prompt(name, variables)\n        return {\n            'status': 'success',\n            'prompt': prompt\n        }\n    except Exception as e:\n        logger.error(f"Prompt composition failed: {e}")\n        return {'error': str(e)}\n\n\nasync def handle_validate(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Validate a composition."""\n    name = data.get('name')\n    comp_type = data.get('type')\n    \n    if not name:\n        return {'error': 'Composition name required'}\n    \n    try:\n        composition = await load_composition(name, comp_type)\n        \n        # Basic validation\n        errors = []\n        warnings = []\n        \n        # Check required fields\n        if not composition.version:\n            errors.append("Missing version field")\n        \n        # Check variable definitions\n        for var_name, var_def in composition.variables.items():\n            if 'type' not in var_def:\n                warnings.append(f"Variable '{var_name}' missing type definition")\n        \n        # Try to resolve with empty variables to check for issues\n        try:\n            await resolve_composition(composition, {})\n        except Exception as e:\n            errors.append(f"Resolution error: {str(e)}")\n        \n        return {\n            'status': 'valid' if not errors else 'invalid',\n            'errors': errors,\n            'warnings': warnings\n        }\n        \n    except Exception as e:\n        return {\n            'status': 'error',\n            'error': str(e)\n        }\n\n\nasync def handle_discover(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Discover available compositions using index."""\n    if not state_manager:\n        return {'error': 'Composition index not available'}\n    \n    # Use index for fast discovery\n    discovered = state_manager.discover_compositions(data)\n    \n    return {\n        'status': 'success',\n        'compositions': discovered,\n        'count': len(discovered)\n    }\n\n\nasync def handle_list(data: Dict[str, Any]) -> Dict[str, Any]:\n    """List all compositions of a given type."""\n    comp_type = data.get('type', 'all')\n    \n    compositions = []\n    \n    if comp_type == 'all':\n        types = ['profile', 'prompt', 'system']\n    else:\n        types = [comp_type]\n    \n    for t in types:\n        discovered = await handle_discover({'type': t})\n        compositions.extend(discovered.get('compositions', []))\n    \n    return {\n        'status': 'success',\n        'compositions': compositions,\n        'count': len(compositions)\n    }\n\n\nasync def handle_get(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Get a composition definition."""\n    name = data.get('name')\n    comp_type = data.get('type')\n    \n    if not name:\n        return {'error': 'Composition name required'}\n    \n    try:\n        composition = await load_composition(name, comp_type)\n        \n        return {\n            'status': 'success',\n            'composition': {\n                'name': composition.name,\n                'type': composition.type,\n                'version': composition.version,\n                'description': composition.description,\n                'author': composition.author,\n                'extends': composition.extends,\n                'mixins': composition.mixins,\n                'components': [\n                    {\n                        'name': c.name,\n                        'source': c.source,\n                        'composition': c.composition,\n                        'has_inline': c.inline is not None,\n                        'has_template': c.template is not None,\n                        'condition': c.condition,\n                        'vars': list(c.vars.keys())\n                    }\n                    for c in composition.components\n                ],\n                'variables': composition.variables,\n                'metadata': composition.metadata\n            }\n        }\n        \n    except Exception as e:\n        return {'error': str(e)}\n\n\nasync def handle_reload(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Reload compositions by rebuilding index."""\n    if not state_manager:\n        return {'error': 'Composition index not available'}\n    \n    # Rebuild index from filesystem\n    indexed_count = state_manager.rebuild_composition_index()\n    \n    logger.info(f"Rebuilt composition index - {indexed_count} compositions")\n    \n    return {\n        'status': 'success',\n        'indexed_count': indexed_count,\n        'message': f'Reindexed {indexed_count} compositions'\n    }\n\n\nasync def handle_load_tree(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Universal tree loading based on composition's declared strategy."""\n    if not state_manager:\n        return {'error': 'Composition index not available'}\n    \n    name = data.get('name')\n    max_depth = data.get('max_depth', 5)\n    \n    if not name:\n        return {'error': 'Composition name required'}\n    \n    try:\n        # Get composition metadata to check loading strategy\n        metadata = state_manager.get_composition_metadata(f"local:{name}")\n        if not metadata:\n            return {'error': f'Composition not found: {name}'}\n        \n        loading_strategy = metadata.get('loading_strategy', 'single')\n        \n        if loading_strategy == 'single':\n            # Just load the one composition\n            composition = await load_composition(name)\n            return {\n                'status': 'success',\n                'strategy': 'single',\n                'compositions': {name: composition}\n            }\n        \n        elif loading_strategy == 'tree':\n            # Load composition + dependencies recursively\n            tree = {}\n            to_load = [(name, 0)]\n            \n            while to_load:\n                comp_name, depth = to_load.pop(0)\n                if depth > max_depth or comp_name in tree:\n                    continue\n                \n                comp = await load_composition(comp_name)\n                tree[comp_name] = comp\n                \n                # Add dependencies to load queue\n                for dep in comp.dependencies or []:\n                    to_load.append((dep, depth + 1))\n                    \n                # Add extends parent\n                if comp.extends:\n                    to_load.append((comp.extends, depth + 1))\n            \n            return {\n                'status': 'success', \n                'strategy': 'tree',\n                'compositions': tree,\n                'loaded_count': len(tree)\n            }\n        \n        else:\n            return {'error': f'Unknown loading strategy: {loading_strategy}'}\n            \n    except Exception as e:\n        return {'error': str(e)}\n\n\nasync def handle_load_bulk(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Universal bulk loading for agent efficiency."""\n    if not state_manager:\n        return {'error': 'Composition index not available'}\n    \n    names = data.get('names', [])\n    if not names:\n        return {'error': 'Composition names list required'}\n    \n    try:\n        # Load all compositions in parallel\n        compositions = {}\n        failed = {}\n        \n        for name in names:\n            try:\n                comp = await load_composition(name)\n                compositions[name] = comp\n            except Exception as e:\n                failed[name] = str(e)\n        \n        return {\n            'status': 'success',\n            'compositions': compositions,\n            'failed': failed,\n            'loaded_count': len(compositions),\n            'failed_count': len(failed)\n        }\n        \n    except Exception as e:\n        return {'error': str(e)}\n\n\nasync def handle_select_composition(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle dynamic composition selection based on context."""\n    try:\n        # Import selector dynamically to avoid circular imports\n        from prompts.composition_selector import CompositionSelector, SelectionContext\n        \n        # Build selection context\n        context = SelectionContext(\n            agent_id=data.get('agent_id', 'unknown'),\n            role=data.get('role'),\n            capabilities=data.get('capabilities', []),\n            task_description=data.get('task'),\n            preferred_style=data.get('style'),\n            context_variables=data.get('context', {})\n        )\n        \n        # Use selector to find best composition\n        selector = CompositionSelector()\n        result = await selector.select_composition(context)\n        \n        # Get additional suggestions if requested\n        max_suggestions = data.get('max_suggestions', 1)\n        suggestions = []\n        \n        if max_suggestions > 1:\n            # Get all scored compositions from selector\n            all_compositions = await selector.get_scored_compositions(context)\n            suggestions = [\n                {\n                    'name': name,\n                    'score': score,\n                    'reasons': reasons\n                }\n                for name, score, reasons in all_compositions[:max_suggestions]\n            ]\n        \n        return {\n            'status': 'success',\n            'selected': result.composition_name,\n            'score': result.score,\n            'reasons': result.reasons,\n            'suggestions': suggestions,\n            'fallback_used': result.fallback_used\n        }\n        \n    except Exception as e:\n        logger.error(f"Composition selection failed: {e}")\n        return {'error': str(e)}\n\n\nasync def handle_create_composition(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Handle runtime composition creation."""\n    try:\n        name = data.get('name')\n        if not name:\n            # Generate unique name\n            import uuid\n            name = f"dynamic_{uuid.uuid4().hex[:8]}"\n        \n        comp_type = data.get('type', 'profile')\n        base_composition = data.get('extends', 'base_agent')\n        \n        # Build composition structure\n        composition = {\n            'name': name,\n            'type': comp_type,\n            'version': '1.0.0',\n            'description': data.get('description', f'Dynamically created {comp_type}'),\n            'author': data.get('author', 'dynamic_agent'),\n            'extends': base_composition,\n            'components': [],\n            'metadata': data.get('metadata', {})\n        }\n        \n        # Add components\n        if 'components' in data:\n            composition['components'] = data['components']\n        else:\n            # Default components based on type\n            if comp_type == 'profile':\n                composition['components'] = [\n                    {\n                        'name': 'agent_config',\n                        'inline': data.get('config', {\n                            'role': data.get('role', 'assistant'),\n                            'model': data.get('model', 'sonnet'),\n                            'capabilities': data.get('capabilities', []),\n                            'tools': data.get('tools', [])\n                        })\n                    }\n                ]\n                if 'prompt' in data:\n                    composition['components'].append({\n                        'name': 'prompt',\n                        'template': data['prompt']\n                    })\n        \n        # Add metadata for dynamic composition\n        composition['metadata'].update({\n            'dynamic': True,\n            'created_at': TimestampManager.format_for_logging(),\n            'parent_agent': data.get('agent_id')\n        })\n        \n        # Save to temporary location (in-memory cache)\n        # In production, could save to disk or state service\n        dynamic_cache_key = f"dynamic_composition:{name}"\n        if state_manager:\n            state_manager.set_state(dynamic_cache_key, composition)\n        \n        return {\n            'status': 'success',\n            'name': name,\n            'composition': composition,\n            'message': f'Created dynamic composition: {name}'\n        }\n        \n    except Exception as e:\n        logger.error(f"Dynamic composition creation failed: {e}")\n        return {'error': str(e)}\n\n\n# Plugin lifecycle\n@hookimpl(trylast=True)  # Run after state service initializes\ndef ksi_startup(config):\n    """Initialize composition service on startup."""\n    global state_manager\n    \n    logger.info("Composition service starting up...")\n    \n    # Get state manager reference from state service\n    try:\n        # Import the state service to get its manager instance\n        from ksi_daemon.plugins.state import state_service\n        state_manager = state_service.state_manager\n        \n        if state_manager:\n            logger.info("State manager available, rebuilding composition index...")\n            # Rebuild composition index on startup\n            indexed_count = state_manager.rebuild_composition_index()\n            logger.info(f"Composition service started - indexed {indexed_count} compositions")\n        else:\n            logger.error("State manager not available from state service")\n        \n    except Exception as e:\n        logger.error(f"Failed to initialize composition index: {e}")\n        import traceback\n        traceback.print_exc()\n        state_manager = None\n    \n    # Ensure directories exist\n    COMPOSITIONS_BASE.mkdir(parents=True, exist_ok=True)\n    FRAGMENTS_BASE.mkdir(parents=True, exist_ok=True)\n    SCHEMAS_BASE.mkdir(parents=True, exist_ok=True)\n    \n    return {"status": "composition_service_ready"}\n\n\n@hookimpl\ndef ksi_shutdown():\n    """Clean up on shutdown."""\n    logger.info("Composition service stopped")\n    return {"status": "composition_service_stopped"}\n\n\n# Module-level marker for plugin discovery\nksi_plugin = True