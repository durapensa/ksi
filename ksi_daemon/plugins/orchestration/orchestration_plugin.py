#!/usr/bin/env python3\n"""\nOrchestration Plugin - Core orchestration engine with declarative patterns\n\nProvides:\n- Pattern loading from YAML compositions\n- Agent lifecycle management\n- Message routing based on patterns\n- Coordination primitives (turn-taking, termination)\n- State tracking and checkpointing\n"""\n\nimport asyncio\nimport json\nimport yaml\nimport uuid\nimport time\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List, Set\nfrom dataclasses import dataclass, field\nimport re\nimport pluggy\n\nfrom ksi_common.logging import get_logger\nfrom ksi_daemon.plugin_utils import plugin_metadata\nfrom ksi_common import TimestampManager\nfrom ksi_daemon.config import config\n\n# Plugin metadata\nplugin_metadata("orchestration", version="1.0.0",\n                description="Declarative multi-agent orchestration patterns")\n\n# Hook implementation marker\nhookimpl = pluggy.HookimplMarker("ksi")\n\n# Module state\nlogger = get_logger("orchestration")\norchestrations: Dict[str, 'OrchestrationInstance'] = {}  # Active orchestrations\nevent_emitter = None  # Set during plugin context\n\n\n@dataclass\nclass AgentInfo:\n    """Information about an agent in an orchestration."""\n    agent_id: str\n    profile: str\n    prompt_template: Optional[str] = None\n    vars: Dict[str, Any] = field(default_factory=dict)\n    spawned: bool = False\n    spawn_result: Optional[Dict[str, Any]] = None\n\n\n@dataclass\nclass RoutingRule:\n    """A message routing rule."""\n    pattern: str\n    from_agent: str\n    to_agent: str\n    condition: Optional[str] = None\n    broadcast: bool = False\n    \n    def matches(self, event_name: str, from_agent: str) -> bool:\n        """Check if this rule matches the event."""\n        # Check event pattern\n        if not self._matches_pattern(event_name, self.pattern):\n            return False\n            \n        # Check from_agent\n        if self.from_agent != "*" and self.from_agent != from_agent:\n            return False\n            \n        return True\n    \n    def _matches_pattern(self, event_name: str, pattern: str) -> bool:\n        """Check if event name matches pattern (supports wildcards)."""\n        if pattern == "*":\n            return True\n        if pattern.endswith("*"):\n            prefix = pattern[:-1]\n            return event_name.startswith(prefix)\n        return event_name == pattern\n    \n    def get_targets(self, agents: Dict[str, AgentInfo], sender: str) -> List[str]:\n        """Get target agents for this rule."""\n        if self.broadcast:\n            # Send to all agents except sender if to_agent is "!sender"\n            if self.to_agent == "!sender":\n                return [aid for aid in agents.keys() if aid != sender]\n            else:\n                return list(agents.keys())\n        else:\n            # Handle special notations\n            if self.to_agent == "!sender":\n                # Send to all except sender (non-broadcast)\n                return [aid for aid in agents.keys() if aid != sender]\n            elif self.to_agent.startswith("!"):\n                # Exclude specific agent\n                exclude = self.to_agent[1:]\n                return [aid for aid in agents.keys() if aid != exclude]\n            else:\n                # Direct routing\n                return [self.to_agent] if self.to_agent in agents else []\n\n\n@dataclass\nclass OrchestrationInstance:\n    """An active orchestration instance."""\n    orchestration_id: str\n    pattern_name: str\n    pattern: Dict[str, Any]\n    agents: Dict[str, AgentInfo] = field(default_factory=dict)\n    routing_rules: List[RoutingRule] = field(default_factory=list)\n    state: str = "initializing"\n    start_time: float = field(default_factory=time.time)\n    message_count: int = 0\n    vars: Dict[str, Any] = field(default_factory=dict)\n    \n    # Coordination state\n    turn_order: List[str] = field(default_factory=list)\n    current_turn: int = 0\n    last_activity: float = field(default_factory=time.time)\n    \n    # Termination tracking\n    rounds_completed: int = 0\n    termination_conditions: Dict[str, Any] = field(default_factory=dict)\n\n\nclass OrchestrationPlugin:\n    """Core orchestration plugin implementation."""\n    \n    def __init__(self):\n        # Use same pattern as composition service - relative to project root\n        self.patterns_dir = Path("var") / "lib" / "compositions" / "orchestrations"\n        self.providers = {}\n        self._load_providers()\n    \n    def _load_providers(self):\n        """Load optional providers if enabled."""\n        # Provider loading not yet implemented\n        pass\n    \n    async def load_pattern(self, pattern_name: str) -> Dict[str, Any]:\n        """Load an orchestration pattern from YAML."""\n        pattern_file = self.patterns_dir / f"{pattern_name}.yaml"\n        \n        if not pattern_file.exists():\n            # Try with .yml extension\n            pattern_file = self.patterns_dir / f"{pattern_name}.yml"\n            \n        if not pattern_file.exists():\n            raise FileNotFoundError(f"Orchestration pattern not found: {pattern_name}")\n        \n        with open(pattern_file, 'r') as f:\n            pattern = yaml.safe_load(f)\n        \n        # Validate required fields\n        required = ['name', 'agents', 'routing']\n        for field in required:\n            if field not in pattern:\n                raise ValueError(f"Orchestration pattern missing required field: {field}")\n        \n        return pattern\n    \n    async def start_orchestration(self, pattern_name: str, vars: Dict[str, Any]) -> Dict[str, Any]:\n        """Start a new orchestration instance."""\n        try:\n            # Load pattern\n            pattern = await self.load_pattern(pattern_name)\n            \n            # Create instance\n            orchestration_id = f"orch_{uuid.uuid4().hex[:8]}"\n            instance = OrchestrationInstance(\n                orchestration_id=orchestration_id,\n                pattern_name=pattern_name,\n                pattern=pattern,\n                vars=vars\n            )\n            \n            # Parse agents\n            for agent_name, agent_config in pattern.get('agents', {}).items():\n                agent_id = f"{orchestration_id}_{agent_name}"\n                instance.agents[agent_id] = AgentInfo(\n                    agent_id=agent_id,\n                    profile=agent_config.get('profile', 'default'),\n                    prompt_template=agent_config.get('prompt_template'),\n                    vars={**vars, **agent_config.get('vars', {})}\n                )\n            \n            # Parse routing rules\n            for rule_config in pattern.get('routing', {}).get('rules', []):\n                rule = RoutingRule(\n                    pattern=rule_config.get('pattern', '*'),\n                    from_agent=rule_config.get('from', '*'),\n                    to_agent=rule_config.get('to', '*'),\n                    condition=rule_config.get('condition'),\n                    broadcast=rule_config.get('broadcast', False)\n                )\n                instance.routing_rules.append(rule)\n            \n            # Parse coordination\n            coord = pattern.get('coordination', {})\n            if 'turn_taking' in coord:\n                turn_config = coord['turn_taking']\n                if turn_config.get('mode') == 'strict_alternation':\n                    instance.turn_order = list(instance.agents.keys())\n            \n            # Parse termination conditions\n            instance.termination_conditions = pattern.get('coordination', {}).get('termination', {})\n            \n            # Store instance\n            orchestrations[orchestration_id] = instance\n            \n            # Spawn agents\n            await self._spawn_agents(instance)\n            \n            instance.state = "running"\n            logger.info(f"Started orchestration {orchestration_id} with pattern {pattern_name}")\n            \n            # Emit start event\n            if event_emitter:\n                await event_emitter("orchestration:started", {\n                    "orchestration_id": orchestration_id,\n                    "pattern": pattern_name,\n                    "agents": list(instance.agents.keys())\n                }, {})\n            \n            return {\n                "orchestration_id": orchestration_id,\n                "status": "started",\n                "agents": list(instance.agents.keys())\n            }\n            \n        except Exception as e:\n            logger.error(f"Failed to start orchestration: {e}")\n            return {\n                "error": str(e),\n                "status": "failed"\n            }\n    \n    async def _spawn_agents(self, instance: OrchestrationInstance):\n        """Spawn all agents for an orchestration."""\n        if not event_emitter:\n            raise RuntimeError("Event emitter not available")\n        \n        spawn_tasks = []\n        for agent_id, agent_info in instance.agents.items():\n            # Prepare spawn data\n            spawn_data = {\n                "agent_id": agent_id,\n                "profile": agent_info.profile,\n                "session_id": f"{instance.orchestration_id}_session"\n            }\n            \n            # Add prompt template if specified\n            if agent_info.prompt_template:\n                spawn_data["composition"] = agent_info.prompt_template\n            \n            # Add context variables\n            spawn_data["context"] = {\n                "orchestration_id": instance.orchestration_id,\n                "pattern": instance.pattern_name,\n                **instance.vars,\n                **agent_info.vars\n            }\n            \n            # Spawn agent\n            spawn_task = event_emitter("agent:spawn", spawn_data, {})\n            spawn_tasks.append((agent_id, spawn_task))\n        \n        # Wait for all spawns\n        for agent_id, task in spawn_tasks:\n            try:\n                result = await task\n                instance.agents[agent_id].spawned = True\n                instance.agents[agent_id].spawn_result = result\n                logger.info(f"Spawned agent {agent_id}")\n            except Exception as e:\n                logger.error(f"Failed to spawn agent {agent_id}: {e}")\n    \n    async def route_message(self, data: Dict[str, Any]) -> Dict[str, Any]:\n        """Route a message according to orchestration rules."""\n        orchestration_id = data.get("orchestration_id")\n        from_agent = data.get("from_agent")\n        event_name = data.get("event", "message")\n        payload = data.get("payload", {})\n        \n        if not orchestration_id or orchestration_id not in orchestrations:\n            return {"error": "Unknown orchestration"}\n        \n        instance = orchestrations[orchestration_id]\n        instance.message_count += 1\n        instance.last_activity = time.time()\n        \n        # Find matching routing rules\n        targets = set()\n        for rule in instance.routing_rules:\n            if rule.matches(event_name, from_agent):\n                rule_targets = rule.get_targets(instance.agents, from_agent)\n                targets.update(rule_targets)\n        \n        # Apply turn-taking if enabled\n        if instance.turn_order and not self._is_agents_turn(instance, from_agent):\n            logger.debug(f"Blocking message from {from_agent} - not their turn")\n            return {"status": "blocked", "reason": "not_agents_turn"}\n        \n        # Route to targets\n        routed_to = []\n        if event_emitter:\n            for target in targets:\n                if target in instance.agents:\n                    # Send message to agent\n                    await event_emitter("agent:send_message", {\n                        "agent_id": target,\n                        "message": {\n                            "type": event_name,\n                            "from": from_agent,\n                            "orchestration_id": orchestration_id,\n                            "payload": payload\n                        }\n                    }, {})\n                    routed_to.append(target)\n        \n        # Update turn if using turn-taking\n        if instance.turn_order:\n            instance.current_turn = (instance.current_turn + 1) % len(instance.turn_order)\n        \n        # Check termination conditions\n        await self._check_termination(instance)\n        \n        return {\n            "status": "routed",\n            "targets": routed_to,\n            "message_count": instance.message_count\n        }\n    \n    def _is_agents_turn(self, instance: OrchestrationInstance, agent_id: str) -> bool:\n        """Check if it's the agent's turn to speak."""\n        if not instance.turn_order:\n            return True\n        \n        current_agent = instance.turn_order[instance.current_turn]\n        return agent_id == current_agent\n    \n    async def _check_termination(self, instance: OrchestrationInstance):\n        """Check if orchestration should terminate."""\n        conditions = instance.termination_conditions.get('conditions', [])\n        \n        for condition in conditions:\n            # Check rounds\n            if 'rounds' in condition:\n                if instance.message_count >= condition['rounds'] * len(instance.agents):\n                    await self._terminate_orchestration(instance, "rounds_completed")\n                    return\n            \n            # Check timeout\n            if 'timeout' in condition:\n                if time.time() - instance.start_time > condition['timeout']:\n                    await self._terminate_orchestration(instance, "timeout")\n                    return\n            \n            # Check event\n            if 'event' in condition:\n                # Event-based termination not yet implemented\n                pass\n    \n    async def _terminate_orchestration(self, instance: OrchestrationInstance, reason: str):\n        """Terminate an orchestration."""\n        logger.info(f"Terminating orchestration {instance.orchestration_id}: {reason}")\n        \n        # Terminate all agents\n        if event_emitter:\n            for agent_id in instance.agents:\n                await event_emitter("agent:terminate", {"agent_id": agent_id}, {})\n        \n        # Update state\n        instance.state = "terminated"\n        \n        # Emit termination event\n        if event_emitter:\n            await event_emitter("orchestration:terminated", {\n                "orchestration_id": instance.orchestration_id,\n                "reason": reason,\n                "duration": time.time() - instance.start_time,\n                "message_count": instance.message_count\n            }, {})\n        \n        # Clean up\n        del orchestrations[instance.orchestration_id]\n\n\n# Create plugin instance\norchestration_plugin = OrchestrationPlugin()\n\n\n@hookimpl\ndef ksi_startup(config):\n    """Initialize orchestration service on startup."""\n    \n    # Ensure orchestration patterns directory exists\n    patterns_dir = orchestration_plugin.patterns_dir\n    patterns_dir.mkdir(parents=True, exist_ok=True)\n    \n    logger.info(f"Orchestration service started - patterns dir: {patterns_dir}")\n    \n    return {\n        "status": "orchestration_ready",\n        "patterns_dir": str(patterns_dir)\n    }\n\n\n@hookimpl\ndef ksi_handle_event(event_name: str, data: Dict[str, Any], context: Dict[str, Any]):\n    """Handle orchestration-related events."""\n    \n    if event_name == "orchestration:start":\n        # Start a new orchestration\n        pattern = data.get("pattern")\n        vars = data.get("vars", {})\n        \n        if not pattern:\n            return {"error": "pattern required"}\n        \n        # Return coroutine for async execution\n        return orchestration_plugin.start_orchestration(pattern, vars)\n    \n    elif event_name == "orchestration:message":\n        # Route a message within an orchestration\n        return orchestration_plugin.route_message(data)\n    \n    elif event_name == "orchestration:status":\n        # Get orchestration status\n        orchestration_id = data.get("orchestration_id")\n        \n        if orchestration_id:\n            if orchestration_id in orchestrations:\n                instance = orchestrations[orchestration_id]\n                return {\n                    "orchestration_id": orchestration_id,\n                    "state": instance.state,\n                    "pattern": instance.pattern_name,\n                    "agents": {\n                        aid: {"spawned": info.spawned, "profile": info.profile}\n                        for aid, info in instance.agents.items()\n                    },\n                    "message_count": instance.message_count,\n                    "duration": time.time() - instance.start_time\n                }\n            else:\n                return {"error": "Orchestration not found"}\n        else:\n            # Return all orchestrations\n            return {\n                "orchestrations": {\n                    oid: {\n                        "state": inst.state,\n                        "pattern": inst.pattern_name,\n                        "agent_count": len(inst.agents),\n                        "message_count": inst.message_count\n                    }\n                    for oid, inst in orchestrations.items()\n                }\n            }\n    \n    elif event_name == "orchestration:terminate":\n        # Manually terminate an orchestration\n        orchestration_id = data.get("orchestration_id")\n        \n        if not orchestration_id or orchestration_id not in orchestrations:\n            return {"error": "Orchestration not found"}\n        \n        instance = orchestrations[orchestration_id]\n        \n        async def _terminate():\n            await orchestration_plugin._terminate_orchestration(instance, "manual")\n            return {"status": "terminated"}\n        \n        return _terminate()\n    \n    return None\n\n\n@hookimpl\ndef ksi_plugin_context(context):\n    """Store plugin context with event emitter."""\n    global event_emitter\n    event_emitter = context.get("emit_event")\n\n\n@hookimpl\ndef ksi_shutdown():\n    """Clean up on shutdown."""\n    # Terminate all active orchestrations\n    for instance in list(orchestrations.values()):\n        asyncio.create_task(\n            orchestration_plugin._terminate_orchestration(instance, "shutdown")\n        )\n    \n    logger.info("Orchestration service shutdown")\n    return {"status": "orchestration_stopped"}\n\n\n# Module-level marker for plugin discovery\nksi_plugin = True