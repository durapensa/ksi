#!/usr/bin/env python3\n"""\nMonitor Plugin - Event log query API for pull-based monitoring\n\nProvides endpoints for querying the daemon event log without broadcast overhead.\nSupports filtering, pagination, and statistics.\n"""\n\nfrom typing import Dict, Any, List, Optional\nimport pluggy\n\nfrom ksi_common.logging import get_logger\nfrom ksi_daemon.plugin_utils import plugin_metadata\n\n# Plugin metadata\nplugin_metadata("monitor", version="1.0.0",\n                description="Event log query API for monitoring")\n\n# Hook implementation marker\nhookimpl = pluggy.HookimplMarker("ksi")\n\n# Module state\nlogger = get_logger("monitor")\nevent_router = None  # Set during startup\n\n\n@hookimpl\ndef ksi_startup(config):\n    """Initialize monitor plugin."""\n    logger.info("Monitor plugin started")\n    return {"plugin.monitor": {"loaded": True}}\n\n\n@hookimpl\ndef ksi_handle_event(event_name: str, data: Dict[str, Any], context: Dict[str, Any]):\n    """Handle monitor-related events."""\n    \n    if event_name == "monitor:get_events":\n        return handle_get_events(data)\n    \n    elif event_name == "monitor:get_stats":\n        return handle_get_stats(data)\n        \n    elif event_name == "monitor:clear_log":\n        return handle_clear_log(data)\n    \n    return None\n\n\n@hookimpl\ndef ksi_plugin_context(context):\n    """Receive plugin context with event router reference."""\n    global event_router\n    event_router = context.get("event_router")\n\n\ndef handle_get_events(data: Dict[str, Any]) -> Dict[str, Any]:\n    """\n    Query event log with filtering and pagination.\n    \n    Args:\n        data: Query parameters:\n            - event_patterns: List of event name patterns (supports wildcards)\n            - client_id: Filter by specific client  \n            - since: Start time (ISO string or timestamp)\n            - until: End time (ISO string or timestamp)\n            - limit: Maximum number of events to return\n            - reverse: Return newest first (default True)\n    \n    Returns:\n        Dictionary with events list and metadata\n    """\n    if not event_router or not hasattr(event_router, 'event_log'):\n        return {"error": "Event log not available"}\n    \n    try:\n        # Extract query parameters\n        event_patterns = data.get("event_patterns")\n        client_id = data.get("client_id") \n        since = data.get("since")\n        until = data.get("until")\n        limit = data.get("limit", 100)  # Default limit\n        reverse = data.get("reverse", True)\n        \n        # Query event log\n        events = event_router.event_log.get_events(\n            event_patterns=event_patterns,\n            client_id=client_id,\n            since=since,\n            until=until,\n            limit=limit,\n            reverse=reverse\n        )\n        \n        # Get stats for metadata\n        stats = event_router.event_log.get_stats()\n        \n        return {\n            "events": events,\n            "count": len(events),\n            "total_events": stats["total_events"],\n            "query": {\n                "event_patterns": event_patterns,\n                "client_id": client_id,\n                "since": since,\n                "until": until,\n                "limit": limit,\n                "reverse": reverse\n            }\n        }\n        \n    except Exception as e:\n        logger.error(f"Failed to query events: {e}")\n        return {"error": f"Query failed: {str(e)}"}\n\n\ndef handle_get_stats(data: Dict[str, Any]) -> Dict[str, Any]:\n    """\n    Get event log statistics.\n    \n    Returns:\n        Dictionary with event log statistics\n    """\n    if not event_router or not hasattr(event_router, 'event_log'):\n        return {"error": "Event log not available"}\n    \n    try:\n        stats = event_router.event_log.get_stats()\n        \n        # Add router stats\n        router_stats = getattr(event_router, 'stats', {})\n        \n        return {\n            "event_log": stats,\n            "router": router_stats\n        }\n        \n    except Exception as e:\n        logger.error(f"Failed to get stats: {e}")\n        return {"error": f"Stats failed: {str(e)}"}\n\n\ndef handle_clear_log(data: Dict[str, Any]) -> Dict[str, Any]:\n    """\n    Clear event log (admin operation).\n    \n    Returns:\n        Confirmation of log clearing\n    """\n    if not event_router or not hasattr(event_router, 'event_log'):\n        return {"error": "Event log not available"}\n    \n    try:\n        # Get stats before clearing\n        old_stats = event_router.event_log.get_stats()\n        \n        # Clear log\n        event_router.event_log.clear()\n        \n        logger.info("Event log cleared by admin request")\n        \n        return {\n            "status": "cleared",\n            "events_cleared": old_stats["total_events"]\n        }\n        \n    except Exception as e:\n        logger.error(f"Failed to clear log: {e}")\n        return {"error": f"Clear failed: {str(e)}"}\n\n\n# Module-level marker for plugin discovery\nksi_plugin = True