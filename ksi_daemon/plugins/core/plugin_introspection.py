#!/usr/bin/env python3\n"""\nPlugin Introspection Service\n\nProvides read-only introspection of the plugin system.\nFollows pluggy best practices - no lifecycle management, just inspection.\n"""\n\nimport pluggy\nfrom typing import Dict, Any, List\n\nfrom ksi_common.logging import get_logger\nfrom ksi_daemon.plugin_utils import plugin_metadata\n\n# Plugin metadata\nplugin_metadata("plugin_introspection", version="1.0.0",\n                description="Read-only plugin system introspection")\n\n# Hook implementation marker\nhookimpl = pluggy.HookimplMarker("ksi")\n\n# Module state\nlogger = get_logger("plugin_introspection")\nplugin_manager = None  # The pluggy PluginManager instance\n\n# Plugin marker\nksi_plugin = True\n\n\n@hookimpl\ndef ksi_handle_event(event_name: str, data: Dict[str, Any], context: Dict[str, Any]):\n    """Handle introspection events."""\n    \n    if event_name == "plugin:list":\n        return list_plugins()\n    \n    elif event_name == "plugin:hooks":\n        return list_hooks()\n    \n    elif event_name == "plugin:inspect":\n        return inspect_plugin(data)\n    \n    return None\n\n\ndef list_plugins() -> Dict[str, Any]:\n    """List all registered plugins."""\n    if not plugin_manager:\n        return {"error": "Plugin manager not available"}\n    \n    plugins = []\n    for name, plugin_obj in plugin_manager.list_name_plugin():\n        plugins.append({\n            "name": name,\n            "type": type(plugin_obj).__name__,\n            "module": getattr(plugin_obj, "__module__", "unknown")\n        })\n    \n    return {\n        "plugins": plugins,\n        "count": len(plugins)\n    }\n\n\ndef list_hooks() -> Dict[str, Any]:\n    """List all available hooks and their implementations."""\n    if not plugin_manager:\n        return {"error": "Plugin manager not available"}\n    \n    hooks = {}\n    \n    # Iterate through all hooks\n    for attr_name in dir(plugin_manager.hook):\n        if attr_name.startswith("ksi_"):\n            hook = getattr(plugin_manager.hook, attr_name)\n            \n            # Get implementations\n            impls = []\n            for impl in hook.get_hookimpls():\n                impls.append({\n                    "plugin": impl.plugin_name,\n                    "function": impl.function.__name__,\n                    "tryfirst": impl.tryfirst,\n                    "trylast": impl.trylast,\n                    "wrapper": impl.hookwrapper\n                })\n            \n            if impls:  # Only include hooks that have implementations\n                hooks[attr_name] = {\n                    "implementations": impls,\n                    "count": len(impls)\n                }\n    \n    return {\n        "hooks": hooks,\n        "total_hooks": len(hooks)\n    }\n\n\ndef inspect_plugin(data: Dict[str, Any]) -> Dict[str, Any]:\n    """Inspect a specific plugin."""\n    if not plugin_manager:\n        return {"error": "Plugin manager not available"}\n    \n    plugin_name = data.get("plugin_name")\n    if not plugin_name:\n        return {"error": "plugin_name required"}\n    \n    # Find the plugin\n    plugin_obj = None\n    for name, obj in plugin_manager.list_name_plugin():\n        if name == plugin_name:\n            plugin_obj = obj\n            break\n    \n    if not plugin_obj:\n        return {"error": f"Plugin '{plugin_name}' not found"}\n    \n    # Get implemented hooks\n    implemented_hooks = []\n    for attr_name in dir(plugin_manager.hook):\n        if attr_name.startswith("ksi_"):\n            hook = getattr(plugin_manager.hook, attr_name)\n            for impl in hook.get_hookimpls():\n                if impl.plugin_name == plugin_name:\n                    implemented_hooks.append({\n                        "name": attr_name,\n                        "function": impl.function.__name__,\n                        "tryfirst": impl.tryfirst,\n                        "trylast": impl.trylast\n                    })\n    \n    # Basic plugin info\n    info = {\n        "name": plugin_name,\n        "type": type(plugin_obj).__name__,\n        "module": getattr(plugin_obj, "__module__", "unknown"),\n        "hooks": implemented_hooks,\n        "hook_count": len(implemented_hooks)\n    }\n    \n    # Add docstring if available\n    if hasattr(plugin_obj, "__doc__") and plugin_obj.__doc__:\n        info["description"] = plugin_obj.__doc__.strip()\n    \n    # Check for common attributes (but don't require them)\n    if hasattr(plugin_obj, "PLUGIN_INFO"):\n        info["plugin_info"] = plugin_obj.PLUGIN_INFO\n    \n    return info\n\n\n@hookimpl\ndef ksi_plugin_context(context: Dict[str, Any]):\n    """Receive plugin context to get access to plugin manager."""\n    global plugin_manager\n    \n    # Get the plugin manager from the loader\n    plugin_loader = context.get("plugin_loader")\n    if plugin_loader:\n        plugin_manager = plugin_loader.pm\n        logger.info(f"Plugin introspection ready, found {len(list(plugin_manager.list_name_plugin()))} plugins")