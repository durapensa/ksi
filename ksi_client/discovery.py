#!/usr/bin/env python3
"""
KSI Client Discovery and Type Generation

Handles event discovery and generates type stubs for IDE support.
"""

from pathlib import Path
from typing import Dict, Any, List, Optional
import structlog

logger = structlog.get_logger("ksi.client.discovery")


class TypeStubGenerator:
    """Generates type stubs (.pyi files) from discovered events."""
    
    @staticmethod
    def generate_stubs(event_cache: Dict[str, List[Dict[str, Any]]],
                      permission_cache: Dict[str, Dict[str, Any]],
                      output_path: Optional[Path] = None) -> str:
        """
        Generate type stubs from discovered events.
        
        Args:
            event_cache: Discovered events by namespace
            permission_cache: Discovered permission profiles
            output_path: Path to write .pyi file (optional)
            
        Returns:
            Generated stub content
        """
        output_path = output_path or Path("ksi_client/types/discovered.pyi")
        
        stub = '''"""
Auto-generated type stubs from KSI daemon discovery.
DO NOT EDIT - This file is automatically generated.
"""

from typing import Dict, Any, Optional, List, Union
from typing_extensions import TypedDict, Literal


# Permission profile types
PermissionProfile = Literal['''
        
        # Add permission profile literals
        if permission_cache:
            profiles = ', '.join(f'"{p}"' for p in permission_cache.keys())
            stub += f"{profiles}]\n\n"
        else:
            stub += '"restricted", "standard", "trusted", "researcher"]\n\n'
        
        # Add tool types if available
        if permission_cache:
            all_tools = set()
            for profile in permission_cache.values():
                tools = profile.get("tools", {})
                all_tools.update(tools.get("allowed", []))
                all_tools.update(tools.get("disallowed", []))
            
            if all_tools:
                stub += "# Available tools\n"
                stub += "Tool = Literal["
                stub += ', '.join(f'"{t}"' for t in sorted(all_tools))
                stub += "]\n\n"
        
        # Generate namespace classes
        for namespace, events in sorted(event_cache.items()):
            class_name = TypeStubGenerator._make_class_name(namespace)
            stub += f"\nclass {class_name}:\n"
            stub += f'    """Event methods for {namespace} namespace."""\n\n'
            
            if not events:
                stub += "    pass\n"
                continue
            
            for event in events:
                method_name = event["event"].split(":")[-1]
                method_stub = TypeStubGenerator._generate_method_stub(method_name, event)
                stub += method_stub + "\n"
        
        # Generate main EventClient class
        stub += "\n\nclass EventClient:\n"
        stub += '    """Self-discovering event client with automatic daemon management."""\n\n'
        
        # Add namespace attributes
        for namespace in sorted(event_cache.keys()):
            attr_name = namespace.replace(":", "_")
            class_name = TypeStubGenerator._make_class_name(namespace)
            stub += f"    {attr_name}: {class_name}\n"
        
        # Add core methods
        stub += '''
    def __init__(self, 
                 client_id: Optional[str] = None,
                 socket_path: Optional[Path] = None,
                 auto_start_daemon: bool = True,
                 discovery_cache_ttl: int = 3600) -> None: ...
    
    async def __aenter__(self) -> "EventClient": ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    
    async def connect(self) -> None: ...
    async def disconnect(self) -> None: ...
    async def discover(self) -> None: ...
    
    async def send_event(self, event_name: str, data: Dict[str, Any] = None,
                        timeout: Optional[float] = None) -> Dict[str, Any]: ...
    
    def subscribe(self, event_pattern: str, handler: Any) -> None: ...
    def unsubscribe(self, event_pattern: str, handler: Any) -> None: ...
    
    def has_event(self, event_name: str) -> bool: ...
    def get_event_info(self, event_name: str) -> Optional[Dict[str, Any]]: ...
    def get_namespaces(self) -> List[str]: ...
    def get_events_in_namespace(self, namespace: str) -> List[Dict[str, Any]]: ...
    
    def get_permission_profiles(self) -> List[str]: ...
    def get_profile_info(self, profile: str) -> Optional[Dict[str, Any]]: ...
    def get_profile_tools(self, profile: str) -> Dict[str, List[str]]: ...
    
    async def create_chat_completion(self, 
                                   prompt: str,
                                   permission_profile: PermissionProfile = "restricted",
                                   session_id: Optional[str] = None,
                                   **kwargs: Any) -> Dict[str, Any]: ...
'''
        
        # Write to file if path provided
        if output_path:
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(stub)
            logger.info(f"Generated type stubs at {output_path}")
        
        return stub
    
    @staticmethod
    def _make_class_name(namespace: str) -> str:
        """Convert namespace to class name."""
        # Convert "system:health" -> "SystemNamespace"
        parts = namespace.split(":")
        name = "".join(p.title() for p in parts)
        return f"{name}Namespace"
    
    @staticmethod
    def _generate_method_stub(method_name: str, event_info: Dict[str, Any]) -> str:
        """Generate a method stub for an event."""
        # Build parameter list
        params = TypeStubGenerator._format_parameters(event_info.get("parameters", {}))
        
        # Build docstring
        docstring = event_info.get("summary", "")
        if event_info.get("description") and event_info["description"] != docstring:
            docstring = event_info["description"]
        
        # Generate method
        stub = f"    async def {method_name}(self"
        if params:
            stub += ", "
            stub += params
        stub += ") -> Dict[str, Any]:\n"
        
        if docstring:
            stub += f'        """{docstring}"""\n'
        stub += "        ...\n"
        
        return stub
    
    @staticmethod
    def _format_parameters(params: Dict[str, Dict[str, Any]]) -> str:
        """Format parameters for method signature."""
        param_list = []
        
        # Separate required and optional parameters
        required_params = []
        optional_params = []
        
        for name, info in params.items():
            param_type = TypeStubGenerator._get_python_type(info)
            
            if info.get("required", False):
                required_params.append(f"{name}: {param_type}")
            else:
                # Get default value
                default = info.get("default", "None")
                if default == "None":
                    optional_params.append(f"{name}: Optional[{param_type}] = None")
                else:
                    optional_params.append(f"{name}: {param_type} = {default}")
        
        # Combine parameters (required first, then optional)
        param_list.extend(required_params)
        param_list.extend(optional_params)
        
        # Always add **kwargs for flexibility
        if param_list:
            return ", ".join(param_list) + ", **kwargs: Any"
        else:
            return "**kwargs: Any"
    
    @staticmethod
    def _get_python_type(param_info: Dict[str, Any]) -> str:
        """Get Python type annotation from parameter info."""
        type_str = param_info.get("type", "Any")
        
        # Handle common type mappings
        type_map = {
            "str": "str",
            "int": "int",
            "float": "float",
            "bool": "bool",
            "list": "List[Any]",
            "dict": "Dict[str, Any]",
            "Any": "Any",
        }
        
        # Check for allowed values (enum-like)
        if param_info.get("allowed_values"):
            values = param_info["allowed_values"]
            if all(isinstance(v, str) for v in values):
                literals = ', '.join(f'"{v}"' for v in values)
                return f"Literal[{literals}]"
        
        return type_map.get(type_str.lower(), "Any")


def generate_type_stubs_for_client(client: 'EventClient',  # type: ignore
                                  output_path: Optional[Path] = None) -> str:
    """
    Generate type stubs from a connected EventClient.
    
    Args:
        client: Connected EventClient with discovered events
        output_path: Path to write .pyi file (optional)
        
    Returns:
        Generated stub content
    """
    if not client._discovered:
        raise RuntimeError("Client must be connected and discovered before generating stubs")
    
    return TypeStubGenerator.generate_stubs(
        client._event_cache,
        client._permission_cache,
        output_path
    )